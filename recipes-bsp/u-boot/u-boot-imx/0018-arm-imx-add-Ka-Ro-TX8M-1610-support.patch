From e2081c2f0400df1e71d505fd72c2242b50d7a9eb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lothar=20Wa=C3=9Fmann?= <LW@KARO-electronics.de>
Date: Tue, 26 Mar 2019 12:28:07 +0100
Subject: [PATCH 18/23] arm: imx: add Ka-Ro TX8M-1610 support

---
 arch/arm/dts/imx8mm-tx8m-1610-u-boot.dtsi          |   12 +
 arch/arm/dts/imx8mm-tx8m-1610.dts                  |  590 ++++++++++
 arch/arm/mach-imx/imx8m/Kconfig                    |    6 +
 arch/arm/mach-imx/spl.c                            |    2 +-
 board/karo/common/Makefile                         |    7 +
 board/karo/common/fdt.c                            |   57 +
 board/karo/tx8mm/Kconfig                           |   20 +
 board/karo/tx8mm/Makefile                          |   12 +
 board/karo/tx8mm/ddr/Makefile                      |   10 +
 board/karo/tx8mm/ddr/ddr.h                         |   59 +
 board/karo/tx8mm/ddr/ddr3l/Makefile                |   13 +
 board/karo/tx8mm/ddr/ddr3l/anamix_common.h         |   88 ++
 board/karo/tx8mm/ddr/ddr3l/ddr3_define.h           |   43 +
 board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c     |   73 ++
 .../ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c     | 1156 ++++++++++++++++++++
 .../tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c   |  277 +++++
 .../ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c |  969 ++++++++++++++++
 .../ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c    |  971 ++++++++++++++++
 board/karo/tx8mm/ddr/ddr_init.c                    |  173 +++
 board/karo/tx8mm/ddr/ddrphy_train.c                |  351 ++++++
 board/karo/tx8mm/ddr/helper.c                      |  102 ++
 .../karo/tx8mm/ddr/wait_ddrphy_training_complete.c |  101 ++
 board/karo/tx8mm/spl.c                             |  306 ++++++
 board/karo/tx8mm/tx8mm.c                           |  535 +++++++++
 configs/tx8m-1610_defconfig                        |  100 ++
 include/configs/tx8mm.h                            |  188 ++++
 27 files changed, 6220 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/dts/imx8mm-tx8m-1610-u-boot.dtsi
 create mode 100644 arch/arm/dts/imx8mm-tx8m-1610.dts
 create mode 100644 board/karo/common/Makefile
 create mode 100644 board/karo/common/fdt.c
 create mode 100644 board/karo/tx8mm/Kconfig
 create mode 100644 board/karo/tx8mm/Makefile
 create mode 100644 board/karo/tx8mm/ddr/Makefile
 create mode 100644 board/karo/tx8mm/ddr/ddr.h
 create mode 100644 board/karo/tx8mm/ddr/ddr3l/Makefile
 create mode 100644 board/karo/tx8mm/ddr/ddr3l/anamix_common.h
 create mode 100644 board/karo/tx8mm/ddr/ddr3l/ddr3_define.h
 create mode 100644 board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c
 create mode 100644 board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
 create mode 100644 board/karo/tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
 create mode 100644 board/karo/tx8mm/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
 create mode 100644 board/karo/tx8mm/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
 create mode 100644 board/karo/tx8mm/ddr/ddr_init.c
 create mode 100644 board/karo/tx8mm/ddr/ddrphy_train.c
 create mode 100644 board/karo/tx8mm/ddr/helper.c
 create mode 100644 board/karo/tx8mm/ddr/wait_ddrphy_training_complete.c
 create mode 100644 board/karo/tx8mm/spl.c
 create mode 100644 board/karo/tx8mm/tx8mm.c
 create mode 100644 configs/tx8m-1610_defconfig
 create mode 100644 include/configs/tx8mm.h

diff --git a/arch/arm/dts/imx8mm-tx8m-1610-u-boot.dtsi b/arch/arm/dts/imx8mm-tx8m-1610-u-boot.dtsi
new file mode 100644
index 0000000000000000000000000000000000000000..a8fb4907476a2559e7f03303b1e707e93e74d0cb
--- /dev/null
+++ b/arch/arm/dts/imx8mm-tx8m-1610-u-boot.dtsi
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ */
+#include "config.h"
+
+/ {
+	config {
+		u-boot,mmc-env-offset = <CONFIG_ENV_OFFSET>;
+	};
+};
diff --git a/arch/arm/dts/imx8mm-tx8m-1610.dts b/arch/arm/dts/imx8mm-tx8m-1610.dts
new file mode 100644
index 0000000000000000000000000000000000000000..2f457314506a4bf62533054ef76baaab41674ac8
--- /dev/null
+++ b/arch/arm/dts/imx8mm-tx8m-1610.dts
@@ -0,0 +1,590 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ */
+
+/dts-v1/;
+
+#include "imx8mm-tx8m-1610-u-boot.dtsi"
+#include "fsl-imx8mm.dtsi"
+
+/ {
+	model = "Ka-Ro electronics TX8M-1610 (NXP i.MX8MM) board";
+	compatible = "karo,imx8mm-tx8m", "fsl,imx8mm";
+
+	aliases {
+		usb-host = &usbotg2;
+		usbotg = &usbotg1;
+		i2c0 = &i2c1;
+		i2c1 = &i2c2;
+		i2c2 = &i2c3;
+	};
+
+	chosen {
+		bootargs = "console=ttymxc0,115200 earlycon=ec_imx6q,0x30860000,115200";
+		stdout-path = &uart1;
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		audio_clk: clock@0 {
+			compatible = "fixed-clock";
+			reg = <0>;
+			#clock-cells = <0>;
+			clock-frequency = <26000000>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led {
+			label = "Heartbeat";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_led>;
+			gpios = <&gpio1 2 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0x40000000>;
+	};
+
+	owire {
+		compatible = "w1-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_owire>;
+		gpios = <&gpio3 25 GPIO_ACTIVE_HIGH>;
+		linux,open-drain;
+	};
+
+	reg_3v3: regulator-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		power-supply = <&buck6_reg>;
+	};
+
+	reg_3v3_etn: regulator-3v3-etn {
+		compatible = "regulator-fixed";
+		regulator-name = "3V3_ETN";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_etnphy_power>;
+		gpio = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		power-supply = <&reg_3v3>;
+	};
+};
+
+&A53_0 {
+	arm-supply = <&buck2_reg>;
+};
+
+&i2c1 {
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	pinctrl-1 = <&pinctrl_i2c1_gpio>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	pmic: bd71837@4b {
+		reg = <0x4b>;
+		compatible = "rohm,bd71837";
+		/* PMIC BD71837 PMIC_nINT GPIO1_IO3 */
+		pinctrl-0 = <&pinctrl_pmic>;
+		gpio_intr = <&gpio1 3 GPIO_ACTIVE_LOW>;
+
+		gpo {
+			rohm,drv = <0x0C>;	/* 0b0000_1100 all gpios with CMOS output mode */
+		};
+
+		regulators {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			bd71837,pmic-buck2-uses-i2c-dvs;
+			bd71837,pmic-buck2-dvs-voltage = <1000000>, <900000>, <0>; /* VDD_ARM: Run-Idle */
+
+			buck1_reg: regulator@0 {
+				reg = <0>;
+				regulator-compatible = "buck1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <1250>;
+			};
+
+			buck2_reg: regulator@1 {
+				reg = <1>;
+				regulator-compatible = "buck2";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <1250>;
+			};
+
+			buck3_reg: regulator@2 {
+				reg = <2>;
+				regulator-compatible = "buck3";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+			};
+
+			buck4_reg: regulator@3 {
+				reg = <3>;
+				regulator-compatible = "buck4";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+			};
+
+			buck5_reg: regulator@4 {
+				reg = <4>;
+				regulator-compatible = "buck5";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6_reg: regulator@5 {
+				reg = <5>;
+				regulator-compatible = "buck6";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck7_reg: regulator@6 {
+				reg = <6>;
+				regulator-compatible = "buck7";
+				regulator-min-microvolt = <1605000>;
+				regulator-max-microvolt = <1995000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck8_reg: regulator@7 {
+				reg = <7>;
+				regulator-compatible = "buck8";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: regulator@8 {
+				reg = <8>;
+				regulator-compatible = "ldo1";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: regulator@9 {
+				reg = <9>;
+				regulator-compatible = "ldo2";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: regulator@10 {
+				reg = <10>;
+				regulator-compatible = "ldo3";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4_reg: regulator@11 {
+				reg = <11>;
+				regulator-compatible = "ldo4";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5_reg: regulator@12 {
+				reg = <12>;
+				regulator-compatible = "ldo5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6_reg: regulator@13 {
+				reg = <13>;
+				regulator-compatible = "ldo6";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo7_reg: regulator@14 {
+				reg = <14>;
+				regulator-compatible = "ldo7";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+};
+
+&i2c3 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+};
+
+&fec1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_fec1 &pinctrl_etnphy_rst>;
+	pinctrl-1 = <&pinctrl_fec1_sleep>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	phy-supply = <&reg_3v3_etn>;
+	phy-reset-gpios = <&gpio1 29 GPIO_ACTIVE_LOW>;
+	phy-reset-duration = <10>;
+	assigned-clock-parents = <&clk IMX8MM_SYS_PLL1_266M>,
+				 <&clk IMX8MM_SYS_PLL2_100M>,
+				 <&clk IMX8MM_SYS_PLL2_50M>;
+	assigned-clock-rates = <0>, <0>, <50000000>, <100000000>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_etnphy_int>;
+			interrupt-parent = <&gpio1>;
+			interrupts = <28 IRQ_TYPE_EDGE_FALLING>;
+			smsc,disable-energy-detect;
+		};
+	};
+};
+
+&uart1 { /* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1 &pinctrl_uart1_rtscts>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2 &pinctrl_uart2_rtscts>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3 &pinctrl_uart3_rtscts>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+&usdhc1 { /* eMMC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2 &pinctrl_usdhc2_cd>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz &pinctrl_usdhc2_cd>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz &pinctrl_usdhc2_cd>;
+	bus-width = <4>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;
+	no-1-8-v;
+	fsl,wp-controller;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3 &pinctrl_usdhc3_cd>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz &pinctrl_usdhc3_cd>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz &pinctrl_usdhc3_cd>;
+	bus-width = <4>;
+	cd-gpios = <&gpio3 8 GPIO_ACTIVE_LOW>;
+	no-1-8-v;
+	fsl,wp-controller;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl_etnphy_int: etnphy-intgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_ENET_RD2_GPIO1_IO28		0x90
+		>;
+	};
+
+	pinctrl_etnphy_power: etnphy-powergrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_ENET_TXC_GPIO1_IO23		0x142
+		>;
+	};
+
+	pinctrl_etnphy_rst: etnphy-rstgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_ENET_RD3_GPIO1_IO29		0x140
+		>;
+	};
+
+	pinctrl_fec1: fec1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_ENET_MDC_ENET1_MDC			0x142
+			MX8MM_IOMUXC_ENET_MDIO_ENET1_MDIO		0x142
+			MX8MM_IOMUXC_ENET_TD2_ENET1_TX_CLK		0x40000016
+			MX8MM_IOMUXC_ENET_TD0_ENET1_RGMII_TD0		0x16
+			MX8MM_IOMUXC_ENET_TD1_ENET1_RGMII_TD1		0x16
+			MX8MM_IOMUXC_ENET_RD0_ENET1_RGMII_RD0		0x90
+			MX8MM_IOMUXC_ENET_RD1_ENET1_RGMII_RD1		0x90
+			MX8MM_IOMUXC_ENET_RXC_ENET1_RX_ER		0x16
+			MX8MM_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x16
+			MX8MM_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x16
+		>;
+	};
+
+	pinctrl_fec1_sleep: fec1-sleepgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_ENET_MDC_ENET1_MDC			0x120
+			MX8MM_IOMUXC_ENET_MDIO_ENET1_MDIO		0x120
+			MX8MM_IOMUXC_ENET_TD2_ENET1_TX_CLK		0x40000120
+			MX8MM_IOMUXC_ENET_TD0_ENET1_RGMII_TD0		0x120
+			MX8MM_IOMUXC_ENET_TD1_ENET1_RGMII_TD1		0x120
+			MX8MM_IOMUXC_ENET_RD0_ENET1_RGMII_RD0		0x120
+			MX8MM_IOMUXC_ENET_RD1_ENET1_RGMII_RD1		0x120
+			MX8MM_IOMUXC_ENET_RXC_ENET1_RX_ER		0x120
+			MX8MM_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x120
+			MX8MM_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x120
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C1_SCL_I2C1_SCL			0x400001c2
+			MX8MM_IOMUXC_I2C1_SDA_I2C1_SDA			0x400001c2
+		>;
+	};
+
+	pinctrl_i2c1_gpio: i2c1-gpiogrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C1_SCL_GPIO5_IO14		0x400001c2
+			MX8MM_IOMUXC_I2C1_SDA_GPIO5_IO15		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C2_SCL_I2C2_SCL			0x400001c2
+			MX8MM_IOMUXC_I2C2_SDA_I2C2_SDA			0x400001c2
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C3_SCL_I2C3_SCL			0x400001c2
+			MX8MM_IOMUXC_I2C3_SDA_I2C3_SDA			0x400001c2
+		>;
+	};
+
+	pinctrl_i2c4: i2c4grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C4_SCL_I2C4_SCL			0x400001c2
+			MX8MM_IOMUXC_I2C4_SDA_I2C4_SDA			0x400001c2
+		>;
+	};
+
+	pinctrl_led: ledgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO02_GPIO1_IO2		0x06
+		>;
+	};
+
+	pinctrl_owire: owiregrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_SAI5_MCLK_GPIO3_IO25		0x400001c0
+		>;
+	};
+
+	pinctrl_pmic: pmicgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO03_GPIO1_IO3		0x1c0
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_UART1_RXD_UART1_DCE_RX		0x140
+			MX8MM_IOMUXC_UART1_TXD_UART1_DCE_TX		0x140
+		>;
+	};
+
+	pinctrl_uart1_rtscts: uart1-rtsctsgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_UART3_TXD_UART1_DCE_RTS_B		0x140
+			MX8MM_IOMUXC_UART3_RXD_UART1_DCE_CTS_B		0x140
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_UART2_RXD_UART2_DCE_RX		0x140
+			MX8MM_IOMUXC_UART2_TXD_UART2_DCE_TX		0x140
+		>;
+	};
+
+	pinctrl_uart2_rtscts: uart2-rtsctsgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_UART4_TXD_UART2_DCE_RTS_B		0x140
+			MX8MM_IOMUXC_UART4_RXD_UART2_DCE_CTS_B		0x140
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_ECSPI1_SCLK_UART3_DCE_RX		0x140
+			MX8MM_IOMUXC_ECSPI1_MOSI_UART3_DCE_TX		0x140
+		>;
+	};
+
+	pinctrl_uart3_rtscts: uart3-rtsctsgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_ECSPI1_SS0_UART3_DCE_RTS_B		0x140
+			MX8MM_IOMUXC_ECSPI1_MISO_UART3_DCE_CTS_B	0x140
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD1_CLK_USDHC1_CLK			0x190
+			MX8MM_IOMUXC_SD1_CMD_USDHC1_CMD			0x150
+			MX8MM_IOMUXC_SD1_DATA0_USDHC1_DATA0		0x1d0
+			MX8MM_IOMUXC_SD1_DATA1_USDHC1_DATA1		0x1d0
+			MX8MM_IOMUXC_SD1_DATA2_USDHC1_DATA2		0x1d0
+			MX8MM_IOMUXC_SD1_DATA3_USDHC1_DATA3		0x1d0
+			MX8MM_IOMUXC_SD1_DATA4_USDHC1_DATA4		0x1d0
+			MX8MM_IOMUXC_SD1_DATA5_USDHC1_DATA5		0x1d0
+			MX8MM_IOMUXC_SD1_DATA6_USDHC1_DATA6		0x1d0
+			MX8MM_IOMUXC_SD1_DATA7_USDHC1_DATA7		0x1d0
+			MX8MM_IOMUXC_SD1_STROBE_USDHC1_STROBE		0x156
+			MX8MM_IOMUXC_SD1_RESET_B_USDHC1_RESET_B		0x156
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x190
+			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d0
+			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d0
+			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d0
+			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d0
+			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d0
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2grp100mhz {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x194
+			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d4
+			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d4
+			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d4
+			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d4
+			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d4
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2grp200mhz {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x196
+			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d6
+			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d6
+			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d6
+			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d6
+			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d6
+		>;
+	};
+
+	pinctrl_usdhc2_cd: usdhc2-cdgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x1c0
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x40000190
+			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d0
+			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d0
+			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d0
+			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d0
+			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d0
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3grp100mhz {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x40000194
+			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d4
+			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d4
+			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d4
+			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d4
+			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d4
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3grp200mhz {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x40000196
+			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d6
+			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d6
+			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d6
+			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d6
+			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d6
+		>;
+	};
+
+	pinctrl_usdhc3_cd: usdhc3-cdgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_DATA02_GPIO3_IO8		0x1c0
+		>;
+	};
+};
diff --git a/arch/arm/mach-imx/imx8m/Kconfig b/arch/arm/mach-imx/imx8m/Kconfig
index 249436c33e155af907adda25a88fd82de8933d51..56971325fe423b36d8c5e7415ac73362935557ee 100644
--- a/arch/arm/mach-imx/imx8m/Kconfig
+++ b/arch/arm/mach-imx/imx8m/Kconfig
@@ -60,6 +60,11 @@ config TARGET_IMX8MM_DDR4_EVK
 	select SUPPORT_SPL
 	select IMX8M_DDR4
 
+config TARGET_TX8M
+	bool "Ka-Ro electronics imx8mm boards"
+	select IMX8MM
+	select SUPPORT_SPL
+
 endchoice
 
 config SYS_SOC
@@ -70,5 +75,6 @@ source "board/freescale/imx8mq_arm2/Kconfig"
 source "board/freescale/imx8mq_phanbell/Kconfig"
 source "board/freescale/imx8mm_evk/Kconfig"
 source "board/freescale/imx8mm_val/Kconfig"
+source "board/karo/tx8mm/Kconfig"
 
 endif
diff --git a/arch/arm/mach-imx/spl.c b/arch/arm/mach-imx/spl.c
index 7b9e19ed1f445e275d7dcdd9d23712d08428b9a3..143c335a9285bb674c27905f1a16e23957092ec6 100644
--- a/arch/arm/mach-imx/spl.c
+++ b/arch/arm/mach-imx/spl.c
@@ -125,7 +125,7 @@ u32 spl_boot_device(void)
 	case SD1_BOOT:
 	case MMC1_BOOT:
 		return BOOT_DEVICE_MMC1;
-#if defined(CONFIG_IMX8MM)
+#if defined(CONFIG_IMX8MM) && !defined(CONFIG_TARGET_TX8M)
 	case SD2_BOOT:
 	case MMC2_BOOT:
 		return BOOT_DEVICE_MMC1;
diff --git a/board/karo/common/Makefile b/board/karo/common/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..d58cf497de1605047851925d7021647a89ca35f6
--- /dev/null
+++ b/board/karo/common/Makefile
@@ -0,0 +1,7 @@
+#
+# Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += fdt.o
diff --git a/board/karo/common/fdt.c b/board/karo/common/fdt.c
new file mode 100644
index 0000000000000000000000000000000000000000..a769276e36d63cc52635158f62afe1bc7f5f56e1
--- /dev/null
+++ b/board/karo/common/fdt.c
@@ -0,0 +1,57 @@
+/*
+ * (C) Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fs.h>
+#include <mmc.h>
+#include "karo.h"
+
+static void karo_set_fdtsize(void *fdt)
+{
+	size_t fdtsize = env_get_hex("fdt_size", 0);
+
+	if (fdtsize == fdt_totalsize(fdt)) {
+		return;
+	}
+	debug("FDT size changed from %zu to %u\n",
+	      fdtsize, fdt_totalsize(fdt));
+	env_set_hex("fdt_size", fdt_totalsize(fdt));
+}
+
+int karo_load_fdt(const char *fdt_file)
+{
+	int ret;
+	const char *dev_type = "mmc";
+	const char *dev_part = "0";
+	ulong fdt_addr = env_get_hex("fdt_addr", _pfx(0x, CONFIG_FDTADDR));
+	loff_t size;
+	void *fdt;
+
+	printf("loading FDT from %s %s '%s'\n", dev_type, dev_part, fdt_file);
+
+	if (!file_exists(dev_type, dev_part, fdt_file, FS_TYPE_ANY)) {
+		printf("'%s' does not exist\n", fdt_file);
+		return -ENOENT;
+	}
+	if (fs_set_blk_dev(dev_type, dev_part, FS_TYPE_ANY))
+		return -ENOENT;
+
+	debug("Loading %s to %08lx\n", fdt_file, fdt_addr);
+	ret = fs_read(fdt_file, fdt_addr, 0, 0, &size);
+	if (ret)
+		return ret;
+	debug("Read %llu byte from '%s'\n", size, fdt_file);
+	fdt = (void *)fdt_addr;
+	debug("Checking FDT header @ %p\n", fdt);
+	if (fdt_check_header(fdt)) {
+		printf("ERROR: No valid DTB found at %p\n", fdt);
+		return -EINVAL;
+	}
+	fdt_shrink_to_minimum(fdt, 4096);
+	karo_set_fdtsize(fdt);
+	set_working_fdt_addr(fdt_addr);
+	return ret;
+}
diff --git a/board/karo/tx8mm/Kconfig b/board/karo/tx8mm/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..3757ba9795a416761e41f1bb0d97449eae7c4c4b
--- /dev/null
+++ b/board/karo/tx8mm/Kconfig
@@ -0,0 +1,20 @@
+if TARGET_TX8M
+
+config SYS_BOARD
+	default "tx8mm"
+
+config SYS_CONFIG_NAME
+	default "tx8mm"
+
+config SYS_VENDOR
+	default "karo"
+
+config TX8MM
+	bool
+	default y
+	select BOARD_LATE_INIT
+	imply FEC_MXC
+	select MII
+	select PHYLIB
+	select MXC_UART
+endif
diff --git a/board/karo/tx8mm/Makefile b/board/karo/tx8mm/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..3a5a9eb5adc0fb6b6072ec503231794984c01202
--- /dev/null
+++ b/board/karo/tx8mm/Makefile
@@ -0,0 +1,12 @@
+#
+# Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+obj-y += ddr/
+else
+obj-y += tx8mm.o
+endif
diff --git a/board/karo/tx8mm/ddr/Makefile b/board/karo/tx8mm/ddr/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..30b5b92189fa7be2464c877c3aba85c514cfe319
--- /dev/null
+++ b/board/karo/tx8mm/ddr/Makefile
@@ -0,0 +1,10 @@
+#
+# Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += helper.o wait_ddrphy_training_complete.o
+obj-$(CONFIG_TARGET_TX8M) += ddrphy_train.o ddr_init.o
+endif
diff --git a/board/karo/tx8mm/ddr/ddr.h b/board/karo/tx8mm/ddr/ddr.h
new file mode 100644
index 0000000000000000000000000000000000000000..66cefce03d6819b6246807b90b92036d0fb3f493
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ * Common file for ddr code
+ */
+
+#ifndef __M845S_DDR_H_
+#define __M845S_DDR_H_
+
+#ifdef DDR_DEBUG
+#define ddr_dbg(fmt, ...) printf("DDR: debug:" fmt, ##__VA_ARGS__)
+#else
+#define ddr_dbg(fmt, ...) do {} while (0)
+#endif
+
+/*******************************************************************
+ Desc: user data type
+
+ *******************************************************************/
+enum fw_type {
+	FW_1D_IMAGE,
+	FW_2D_IMAGE,
+};
+/*******************************************************************
+ Desc: prototype
+
+ *******************************************************************/
+void ddr_init(void);
+void ddr_load_train_code(enum fw_type type);
+void wait_ddrphy_training_complete(void);
+void dwc_ddrphy_phyinit_userCustom_E_setDfiClk(unsigned int pstate);
+void dwc_ddrphy_phyinit_userCustom_J_enterMissionMode(void);
+void dwc_ddrphy_phyinit_userCustom_customPostTrain(void);
+void dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy(void);
+void dwc_ddrphy_phyinit_userCustom_A_bringupPower(void);
+void dwc_ddrphy_phyinit_userCustom_overrideUserInput(void);
+void dwc_ddrphy_phyinit_userCustom_H_readMsgBlock(unsigned int run_2D);
+void dwc_ddrphy_phyinit_userCustom_G_waitFwDone(void);
+
+/*******************************************************************
+ Desc: definition
+
+ *******************************************************************/
+static inline void reg32_write(unsigned long addr, u32 val)
+{
+	writel(val, addr);
+}
+
+static inline uint32_t reg32_read(unsigned long addr)
+{
+	return readl(addr);
+}
+
+static inline void reg32setbit(unsigned long addr, u32 bit)
+{
+	setbits_le32(addr, (1 << bit));
+}
+#endif
diff --git a/board/karo/tx8mm/ddr/ddr3l/Makefile b/board/karo/tx8mm/ddr/ddr3l/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..dac4d50678318cc8f6467f454cf7c25ba14a8f6d
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr3l/Makefile
@@ -0,0 +1,13 @@
+#
+# Copyright 2018 NXP
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += ddr3_phyinit_task.o
+obj-y += ddr3_phyinit_train_sw_ffc_fw09.o
+obj-y += ddr3_sw_fast_freq_chg_fw09.o
+obj-y += restore_1d2d_trained_csr_ddr3_p012.o
+obj-y += save_1d2d_trained_csr_ddr3_p012.o
+endif
diff --git a/board/karo/tx8mm/ddr/ddr3l/anamix_common.h b/board/karo/tx8mm/ddr/ddr3l/anamix_common.h
new file mode 100644
index 0000000000000000000000000000000000000000..2413fe1e38d92052c0e7372b3e8118fec9a596af
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr3l/anamix_common.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef ANAMIX_COMMON_TMP_H
+#define ANAMIX_COMMON_TMP_H
+
+/* ANAMIX Address Definitions */
+#define ANAMIX_PLL_BASE_ADDR		0x30360000
+#define ANAMIX_OSC_BASE_ADDR		0x30270000
+#define ANAMIX_TSN_BASE_ADDR		0x30260000
+
+/*  PLL TOP REG */
+#define AUDIO_PLL1_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x00)
+#define AUDIO_PLL1_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x04)
+#define AUDIO_PLL1_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x08)
+#define AUDIO_PLL1_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x0c)
+#define AUDIO_PLL1_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x10)
+#define AUDIO_PLL2_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x14)
+#define AUDIO_PLL2_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x18)
+#define AUDIO_PLL2_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x1c)
+#define AUDIO_PLL2_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x20)
+#define AUDIO_PLL2_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x24)
+#define VIDEO_PLL1_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x28)
+#define VIDEO_PLL1_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x2c)
+#define VIDEO_PLL1_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x30)
+#define VIDEO_PLL1_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x34)
+#define VIDEO_PLL1_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x38)
+#define VIDEO_PLL2_GNRL_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x3c)
+#define VIDEO_PLL2_FDIV_CTL0_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x40)
+#define VIDEO_PLL2_FDIV_CTL1_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x44)
+#define VIDEO_PLL2_SSCG_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x48)
+#define VIDEO_PLL2_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x4c)
+#define DRAM_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x50)
+#define DRAM_PLL_FDIV_CTL0_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x54)
+#define DRAM_PLL_FDIV_CTL1_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x58)
+#define DRAM_PLL_SSCG_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x5c)
+#define DRAM_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x60)
+#define GPU_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x64)
+#define GPU_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x68)
+#define GPU_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x6c)
+#define GPU_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x70)
+#define VPU_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x74)
+#define VPU_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x78)
+#define VPU_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x7c)
+#define VPU_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x80)
+#define ARM_PLL_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x84)
+#define ARM_PLL_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x88)
+#define ARM_PLL_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x8c)
+#define ARM_PLL_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x90)
+#define SYS_PLL1_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x94)
+#define SYS_PLL1_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x98)
+#define SYS_PLL1_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x9c)
+#define SYS_PLL1_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x100)
+#define SYS_PLL2_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x104)
+#define SYS_PLL2_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x108)
+#define SYS_PLL2_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x10c)
+#define SYS_PLL2_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x110)
+#define SYS_PLL3_GNRL_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x114)
+#define SYS_PLL3_DIV_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x118)
+#define SYS_PLL3_LOCKD_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x11c)
+#define SYS_PLL3_MINT_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x120)
+#define ANAMIX_MISC_CTL_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x124)
+#define ANAMIX_CLK_MINT_CTL_ADDR	(ANAMIX_PLL_BASE_ADDR + 0x128)
+
+/* TMP SNSR REG */
+#define TER_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x00)
+#define TSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x04)
+#define TIER_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x08)
+#define TIDR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x0c)
+#define TMHTITR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x10)
+#define TMHTATR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x14)
+#define TMHTACTR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x18)
+#define TSCR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x1c)
+#define TRITSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x20)
+#define TRATSR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x24)
+#define TASR_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x28)
+#define TTMC_ADDR			(ANAMIX_TSN_BASE_ADDR + 0x2c)
+
+/* OSC */
+#define SYS_OSCNML_CTL0_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x00)
+#define SYS_OSCNML_CTL1_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x04)
+#define HDMI_OSCNML_CTL0_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x8000)
+#define HDMI_OSCNML_CTL1_ADDR		(ANAMIX_OSC_BASE_ADDR + 0x8004)
+
+#endif
diff --git a/board/karo/tx8mm/ddr/ddr3l/ddr3_define.h b/board/karo/tx8mm/ddr/ddr3l/ddr3_define.h
new file mode 100644
index 0000000000000000000000000000000000000000..e2ce7271afda5d8ea2ca3a0aea85584d8ab80053
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr3l/ddr3_define.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef DDR3_DEFINE_H
+#define DDR3_DEFINE_H
+
+#include "../ddr.h"
+
+#define RUN_ON_SILICON
+
+#ifdef DDR3_1600MTS_SWFFC_RET
+	#define DDR3_SW_FFC
+#endif
+
+#define SAVE_DDRPHY_TRAIN_ADDR		0x180000
+#define DDR_CSD1_BASE_ADDR		0x40000000
+#define DDR_CSD2_BASE_ADDR		0x80000000
+
+#define ANAMIX_PLL_BASE_ADDR		0x30360000
+#define HW_DRAM_PLL_CFG0_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x60)
+#define HW_DRAM_PLL_CFG1_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x64)
+#define HW_DRAM_PLL_CFG2_ADDR		(ANAMIX_PLL_BASE_ADDR + 0x68)
+#define GPC_PU_PWRHSK			0x303A01FC
+#define GPC_TOP_CONFIG_OFFSET		0x0000
+#define AIPS1_ARB_BASE_ADDR		0x30000000
+#define AIPS_TZ1_BASE_ADDR		AIPS1_ARB_BASE_ADDR
+#define AIPS1_OFF_BASE_ADDR		(AIPS_TZ1_BASE_ADDR + 0x200000)
+#define CCM_IPS_BASE_ADDR		(AIPS1_OFF_BASE_ADDR + 0x180000)
+#define CCM_SRC_CTRL_OFFSET		(CCM_IPS_BASE_ADDR + 0x800)
+#define CCM_SRC_CTRL(n)			(CCM_SRC_CTRL_OFFSET + 0x10 * (n))
+
+#define dwc_ddrphy_apb_wr(addr, data)	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * (addr), data)
+#define dwc_ddrphy_apb_rd(addr)		reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * (addr))
+#define	 reg32clrbit(addr, bitpos)	reg32_write((addr), reg32_read(addr) & ~(1 << (bitpos)))
+
+void restore_1d2d_trained_csr_ddr3_p012(unsigned int addr);
+void save_1d2d_trained_csr_ddr3_p012(unsigned int addr);
+void ddr3_phyinit_train_sw_ffc(unsigned int after_retention);
+
+#endif
diff --git a/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c b/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c
new file mode 100644
index 0000000000000000000000000000000000000000..fb1bfe41624dd3ec5ca388e9a7d97c85629b34f5
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_task.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "ddr3_define.h"
+
+void dwc_ddrphy_phyinit_userCustom_E_setDfiClk (unsigned int pstate) {
+	if (pstate == 0) {
+		ddr_dbg("C: 1 ...\n");
+		dram_pll_init(DRAM_PLL_OUT_400M);
+	} else if (pstate == 1) {
+		ddr_dbg("C: 2 ...\n");
+		dram_pll_init(DRAM_PLL_OUT_266M);
+	} else if (pstate == 2) {
+		ddr_dbg("C: 3 ...\n");
+		dram_pll_init(DRAM_PLL_OUT_167M);
+	} else {
+		printf("C: no freq match\n");
+	}
+}
+
+void dwc_ddrphy_phyinit_userCustom_G_waitFwDone(void)
+{
+	wait_ddrphy_training_complete();
+}
+void dwc_ddrphy_phyinit_userCustom_overrideUserInput (void) {}
+void dwc_ddrphy_phyinit_userCustom_A_bringupPower (void) {}
+void dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy (void) {}
+void dwc_ddrphy_phyinit_userCustom_H_readMsgBlock(unsigned int Train2D) {}
+void dwc_ddrphy_phyinit_userCustom_customPostTrain(void) {}
+void dwc_ddrphy_phyinit_userCustom_J_enterMissionMode(void) {}
+
+void ddr3_mr_write(unsigned int mr, unsigned int data, unsigned int read, unsigned int rank)
+{
+	unsigned int tmp, mr_mirror, data_mirror;
+
+	/* 1. Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction. No */
+	/* writes should be performed to MRCTRL0 and MRCTRL1 if MRSTAT.mr_wr_busy = 1. */
+	do {
+		tmp = reg32_read(DDRC_MRSTAT(0));
+	} while (tmp & 0x1);
+
+	/* 2. Write the MRCTRL0.mr_type, MRCTRL0.mr_addr, MRCTRL0.mr_rank and (for MRWs) */
+	/* MRCTRL1.mr_data to define the MR transaction. */
+	/*  (A3, A4), (A5, A6), (A7, A8), (BA0, BA1),*/
+	tmp = reg32_read(DDRC_DIMMCTL(0));
+	if ((tmp & 0x2) && (rank == 0x2)) {
+	    mr_mirror = (mr & 0x4) | ((mr & 0x1) << 1) | ((mr & 0x2) >> 1);/* BA0, BA1 swap */
+		data_mirror = (data & 0xfe07) | ((data & 0x8) << 1) | ((data & 0x10) >> 1) | ((data & 0x20) << 1) | ((data & 0x40) >> 1) | ((data & 0x80) << 1) | ((data & 0x100) >> 1);
+	} else {
+	    mr_mirror = mr;
+	    data_mirror = data;
+	}
+
+	reg32_write(DDRC_MRCTRL0(0), read | (mr_mirror << 12) | (rank << 4));
+	reg32_write(DDRC_MRCTRL1(0), data_mirror);
+
+	/* 3. In a separate APB transaction, write the MRCTRL0.mr_wr to 1. This bit is self-clearing, and triggers */
+	/* the MR transaction. The uMCTL2 then asserts the MRSTAT.mr_wr_busy while it performs the MR */
+	/* transaction to SDRAM, and no further accesses can be initiated until it is deasserted. */
+	reg32setbit(DDRC_MRCTRL0(0), 31);
+	do {
+		tmp = reg32_read(DDRC_MRSTAT(0));
+	} while (tmp);
+
+}
diff --git a/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c b/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
new file mode 100644
index 0000000000000000000000000000000000000000..0cf71a7675daada1ece38f35fdbfa0f7cd8c8f9c
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr3l/ddr3_phyinit_train_sw_ffc_fw09.c
@@ -0,0 +1,1156 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "../ddr.h"
+#include "ddr3_define.h"
+
+void ddr3_phyinit_train_sw_ffc(unsigned int after_retention)
+{
+	/*  [dwc_ddrphy_phyinit_main] Start of dwc_ddrphy_phyinit_main() */
+	/*  [dwc_ddrphy_phyinit_sequence] Start of dwc_ddrphy_phyinit_sequence() */
+	/*  [dwc_ddrphy_phyinit_initStruct] Start of dwc_ddrphy_phyinit_initStruct() */
+	/*  [dwc_ddrphy_phyinit_initStruct] End of dwc_ddrphy_phyinit_initStruct() */
+	/*  [dwc_ddrphy_phyinit_setDefault] Start of dwc_ddrphy_phyinit_setDefault() */
+	/*  [dwc_ddrphy_phyinit_setDefault] End of dwc_ddrphy_phyinit_setDefault() */
+
+
+	/*  ############################################################## */
+	/*  */
+	/*   dwc_ddrphy_phyinit_userCustom_overrideUserInput is a user-editable function. */
+	/*   */
+	/*   See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/*  ############################################################## */
+
+	dwc_ddrphy_phyinit_userCustom_overrideUserInput ();
+	/*  */
+	/*   [dwc_ddrphy_phyinit_userCustom_overrideUserInput] End of dwc_ddrphy_phyinit_userCustom_overrideUserInput() */
+
+
+	/*  ############################################################## */
+	/*   */
+	/*   Step (A) : Bring up VDD, VDDQ, and VAA */
+	/*   */
+	/*   See PhyInit App Note for detailed description and function usage */
+	/*   */
+	/*  ############################################################## */
+
+
+	dwc_ddrphy_phyinit_userCustom_A_bringupPower ();
+
+	/*  [dwc_ddrphy_phyinit_userCustom_A_bringupPower] End of dwc_ddrphy_phyinit_userCustom_A_bringupPower() */
+	/*  [dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy] Start of dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy() */
+	/*  */
+	/*  */
+	/*  ############################################################## */
+	/*   */
+	/*   Step (B) Start Clocks and Reset the PHY */
+	/*   */
+	/*   See PhyInit App Note for detailed description and function usage */
+	/*   */
+	/*  ############################################################## */
+	/*  */
+	/*  */
+	dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy ();
+
+	/*  [dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy] End of dwc_ddrphy_phyinit_userCustom_B_startClockResetPhy() */
+	/*  */
+
+	/*  ############################################################## */
+	/*   */
+	/*   Step (C) Initialize PHY Configuration */
+	/*   */
+	/*   Load the required PHY configuration registers for the appropriate mode and memory configuration */
+	/*   */
+	/*  ############################################################## */
+	/*  */
+
+	/*   [phyinit_C_initPhyConfig] Start of dwc_ddrphy_phyinit_C_initPhyConfig() */
+	/*  */
+	/*  ############################################################## */
+	/*   TxPreDrvMode[2] = 0 */
+	/*  ############################################################## */
+	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
+	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreP to 0xf */
+	/*   [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxSlewRate::TxPreN to 0xc */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x1005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p0 */
+	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
+	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreP to 0xf */
+	/*   [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxSlewRate::TxPreN to 0xc */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x11005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p1 */
+	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreDrvMode to 0x3 */
+	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreP to 0xf */
+	/*   [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxSlewRate::TxPreN to 0xc */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for TxSlewRate::TxPreP and TxSlewRate::TxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x21005f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21015f, 0x3cf); /*  DWC_DDRPHYA_DBYTE0_TxSlewRate_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21105f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21115f, 0x3cf); /*  DWC_DDRPHYA_DBYTE1_TxSlewRate_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21205f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21215f, 0x3cf); /*  DWC_DDRPHYA_DBYTE2_TxSlewRate_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21305f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21315f, 0x3cf); /*  DWC_DDRPHYA_DBYTE3_TxSlewRate_b1_p2 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=0 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=0 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=0 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x55, 0x365); /*  DWC_DDRPHYA_ANIB0_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=1 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=1 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=1 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x1055, 0x365); /*  DWC_DDRPHYA_ANIB1_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=2 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=2 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=2 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x2055, 0x365); /*  DWC_DDRPHYA_ANIB2_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=3 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=3 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=3 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x3055, 0x365); /*  DWC_DDRPHYA_ANIB3_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x0, ANIB=4 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=4 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=4 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x4055, 0x65); /*  DWC_DDRPHYA_ANIB4_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x0, ANIB=5 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=5 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=5 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x5055, 0x65); /*  DWC_DDRPHYA_ANIB5_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=6 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=6 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=6 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x6055, 0x365); /*  DWC_DDRPHYA_ANIB6_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=7 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=7 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=7 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x7055, 0x365); /*  DWC_DDRPHYA_ANIB7_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=8 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=8 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=8 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x8055, 0x365); /*  DWC_DDRPHYA_ANIB8_ATxSlewRate */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreDrvMode to 0x3, ANIB=9 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreP to 0x5, ANIB=9 */
+	/*   [phyinit_C_initPhyConfig] Programming ATxSlewRate::ATxPreN to 0x6, ANIB=9 */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Optimal setting for ATxSlewRate::ATxPreP and ATxSlewRate::ATxPreP are technology specific. */
+	/*   [phyinit_C_initPhyConfig] ### NOTE ### Please consult the "Output Slew Rate" section of HSpice Model App Note in specific technology for recommended settings */
+
+	dwc_ddrphy_apb_wr(0x9055, 0x365); /*  DWC_DDRPHYA_ANIB9_ATxSlewRate */
+	dwc_ddrphy_apb_wr(0x200c5, 0xb); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0,  Memclk=800MHz, Programming PllCtrl2 to b based on DfiClk frequency = 400. */
+	dwc_ddrphy_apb_wr(0x1200c5, 0x7); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1,  Memclk=266MHz, Programming PllCtrl2 to 7 based on DfiClk frequency = 133. */
+	dwc_ddrphy_apb_wr(0x2200c5, 0x7); /*  DWC_DDRPHYA_MASTER0_PllCtrl2_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2,  Memclk=166MHz, Programming PllCtrl2 to 7 based on DfiClk frequency = 83. */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  Program ARdPtrInitVal based on Frequency and PLL Bypass inputs */
+	/*  The values programmed here assume ideal properties of DfiClk */
+	/*  and Pclk including: */
+	/*  - DfiClk skew */
+	/*  - DfiClk jitter */
+	/*  - DfiClk PVT variations */
+	/*  - Pclk skew */
+	/*  - Pclk jitter */
+	/*  */
+	/*  PLL Bypassed mode: */
+	/*      For MemClk frequency > 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 2-6 */
+	/*      For MemClk frequency < 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 1-6 */
+	/*  */
+	/*  PLL Enabled mode: */
+	/*      For MemClk frequency > 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 1-6 */
+	/*      For MemClk frequency < 933MHz, the valid range of ARdPtrInitVal_p0[3:0] is: 0-6 */
+	/*  */
+	/* ############################################################## */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming ARdPtrInitVal to 0x1 */
+	dwc_ddrphy_apb_wr(0x2002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming ARdPtrInitVal to 0x1 */
+	dwc_ddrphy_apb_wr(0x12002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming ARdPtrInitVal to 0x1 */
+	dwc_ddrphy_apb_wr(0x22002e, 0x1); /*  DWC_DDRPHYA_MASTER0_ARdPtrInitVal_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DqsPreambleControl to 0x8 */
+	dwc_ddrphy_apb_wr(0x20024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DbyteDllModeCntrl to 0x0 */
+	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DqsPreambleControl to 0x8 */
+	dwc_ddrphy_apb_wr(0x120024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DbyteDllModeCntrl to 0x0 */
+	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::TwoTckRxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::TwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::PositionDfeInit to 0x2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4TglTwoTckTxDqsPre to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4PostambleExt to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl::LP4SttcPreBridgeRxEn to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DqsPreambleControl to 0x8 */
+	dwc_ddrphy_apb_wr(0x220024, 0x8); /*  DWC_DDRPHYA_MASTER0_DqsPreambleControl_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DbyteDllModeCntrl to 0x0 */
+	dwc_ddrphy_apb_wr(0x2003a, 0x0); /*  DWC_DDRPHYA_MASTER0_DbyteDllModeCntrl */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming ProcOdtTimeCtl to 0xa */
+	dwc_ddrphy_apb_wr(0x20056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming ProcOdtTimeCtl to 0xa */
+	dwc_ddrphy_apb_wr(0x120056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming ProcOdtTimeCtl to 0xa */
+	dwc_ddrphy_apb_wr(0x220056, 0xa); /*  DWC_DDRPHYA_MASTER0_ProcOdtTimeCtl_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
+	dwc_ddrphy_apb_wr(0x1004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p0 */
+	dwc_ddrphy_apb_wr(0x1304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p0 */
+	dwc_ddrphy_apb_wr(0x1314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
+	dwc_ddrphy_apb_wr(0x11004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p1 */
+	dwc_ddrphy_apb_wr(0x11304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p1 */
+	dwc_ddrphy_apb_wr(0x11314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxOdtDrvStren::ODTStrenP to 0x18 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxOdtDrvStren::ODTStrenN to 0x18 */
+	dwc_ddrphy_apb_wr(0x21004d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21014d, 0x618); /*  DWC_DDRPHYA_DBYTE0_TxOdtDrvStren_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21104d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21114d, 0x618); /*  DWC_DDRPHYA_DBYTE1_TxOdtDrvStren_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21204d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21214d, 0x618); /*  DWC_DDRPHYA_DBYTE2_TxOdtDrvStren_b1_p2 */
+	dwc_ddrphy_apb_wr(0x21304d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b0_p2 */
+	dwc_ddrphy_apb_wr(0x21314d, 0x618); /*  DWC_DDRPHYA_DBYTE3_TxOdtDrvStren_b1_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
+	dwc_ddrphy_apb_wr(0x10049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p0 */
+	dwc_ddrphy_apb_wr(0x10149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p0 */
+	dwc_ddrphy_apb_wr(0x11049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p0 */
+	dwc_ddrphy_apb_wr(0x11149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p0 */
+	dwc_ddrphy_apb_wr(0x12049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p0 */
+	dwc_ddrphy_apb_wr(0x12149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p0 */
+	dwc_ddrphy_apb_wr(0x13049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p0 */
+	dwc_ddrphy_apb_wr(0x13149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
+	dwc_ddrphy_apb_wr(0x110049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p1 */
+	dwc_ddrphy_apb_wr(0x110149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p1 */
+	dwc_ddrphy_apb_wr(0x111049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p1 */
+	dwc_ddrphy_apb_wr(0x111149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p1 */
+	dwc_ddrphy_apb_wr(0x112049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p1 */
+	dwc_ddrphy_apb_wr(0x112149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p1 */
+	dwc_ddrphy_apb_wr(0x113049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p1 */
+	dwc_ddrphy_apb_wr(0x113149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqP to 0x38 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TxImpedanceCtrl1::DrvStrenFSDqN to 0x38 */
+	dwc_ddrphy_apb_wr(0x210049, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b0_p2 */
+	dwc_ddrphy_apb_wr(0x210149, 0xe38); /*  DWC_DDRPHYA_DBYTE0_TxImpedanceCtrl1_b1_p2 */
+	dwc_ddrphy_apb_wr(0x211049, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b0_p2 */
+	dwc_ddrphy_apb_wr(0x211149, 0xe38); /*  DWC_DDRPHYA_DBYTE1_TxImpedanceCtrl1_b1_p2 */
+	dwc_ddrphy_apb_wr(0x212049, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b0_p2 */
+	dwc_ddrphy_apb_wr(0x212149, 0xe38); /*  DWC_DDRPHYA_DBYTE2_TxImpedanceCtrl1_b1_p2 */
+	dwc_ddrphy_apb_wr(0x213049, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b0_p2 */
+	dwc_ddrphy_apb_wr(0x213149, 0xe38); /*  DWC_DDRPHYA_DBYTE3_TxImpedanceCtrl1_b1_p2 */
+	/*  [phyinit_C_initPhyConfig] Programming ATxImpedance::ADrvStrenP to 0x3 */
+	/*  [phyinit_C_initPhyConfig] Programming ATxImpedance::ADrvStrenN to 0x3 */
+	dwc_ddrphy_apb_wr(0x43, 0x63); /*  DWC_DDRPHYA_ANIB0_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x1043, 0x63); /*  DWC_DDRPHYA_ANIB1_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x2043, 0x63); /*  DWC_DDRPHYA_ANIB2_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x3043, 0x63); /*  DWC_DDRPHYA_ANIB3_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x4043, 0x63); /*  DWC_DDRPHYA_ANIB4_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x5043, 0x63); /*  DWC_DDRPHYA_ANIB5_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x6043, 0x63); /*  DWC_DDRPHYA_ANIB6_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x7043, 0x63); /*  DWC_DDRPHYA_ANIB7_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x8043, 0x63); /*  DWC_DDRPHYA_ANIB8_ATxImpedance */
+	dwc_ddrphy_apb_wr(0x9043, 0x63); /*  DWC_DDRPHYA_ANIB9_ATxImpedance */
+	/*  [phyinit_C_initPhyConfig] Programming DfiMode to 0x5 */
+	dwc_ddrphy_apb_wr(0x20018, 0x5); /*  DWC_DDRPHYA_MASTER0_DfiMode */
+	/*  [phyinit_C_initPhyConfig] Programming DfiCAMode to 0x0 */
+	dwc_ddrphy_apb_wr(0x20075, 0x0); /*  DWC_DDRPHYA_MASTER0_DfiCAMode */
+	/*  [phyinit_C_initPhyConfig] Programming CalDrvStr0::CalDrvStrPd50 to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Programming CalDrvStr0::CalDrvStrPu50 to 0x0 */
+	dwc_ddrphy_apb_wr(0x20050, 0x0); /*  DWC_DDRPHYA_MASTER0_CalDrvStr0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x190 */
+	dwc_ddrphy_apb_wr(0x20008, 0x190); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x85 */
+	dwc_ddrphy_apb_wr(0x120008, 0x85); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming CalUclkInfo::CalUClkTicksPer1uS to 0x53 */
+	dwc_ddrphy_apb_wr(0x220008, 0x53); /*  DWC_DDRPHYA_MASTER0_CalUclkInfo_p2 */
+	/*  [phyinit_C_initPhyConfig] Programming CalRate::CalInterval to 0x9 */
+	/*  [phyinit_C_initPhyConfig] Programming CalRate::CalOnce to 0x0 */
+	dwc_ddrphy_apb_wr(0x20088, 0x9); /*  DWC_DDRPHYA_MASTER0_CalRate */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming VrefInGlobal to 0xf8 */
+	dwc_ddrphy_apb_wr(0x200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Programming DqDqsRcvCntrl to 0x581 */
+	dwc_ddrphy_apb_wr(0x10043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p0 */
+	dwc_ddrphy_apb_wr(0x10143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p0 */
+	dwc_ddrphy_apb_wr(0x11043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p0 */
+	dwc_ddrphy_apb_wr(0x11143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p0 */
+	dwc_ddrphy_apb_wr(0x12043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p0 */
+	dwc_ddrphy_apb_wr(0x12143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p0 */
+	dwc_ddrphy_apb_wr(0x13043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p0 */
+	dwc_ddrphy_apb_wr(0x13143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming VrefInGlobal to 0xf8 */
+	dwc_ddrphy_apb_wr(0x1200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Programming DqDqsRcvCntrl to 0x581 */
+	dwc_ddrphy_apb_wr(0x110043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p1 */
+	dwc_ddrphy_apb_wr(0x110143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p1 */
+	dwc_ddrphy_apb_wr(0x111043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p1 */
+	dwc_ddrphy_apb_wr(0x111143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p1 */
+	dwc_ddrphy_apb_wr(0x112043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p1 */
+	dwc_ddrphy_apb_wr(0x112143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p1 */
+	dwc_ddrphy_apb_wr(0x113043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p1 */
+	dwc_ddrphy_apb_wr(0x113143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal::GlobalVrefInSel to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal::GlobalVrefInDAC to 0x1f */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming VrefInGlobal to 0xf8 */
+	dwc_ddrphy_apb_wr(0x2200b2, 0xf8); /*  DWC_DDRPHYA_MASTER0_VrefInGlobal_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming DqDqsRcvCntrl::MajorModeDbyte to 0x0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Programming DqDqsRcvCntrl to 0x581 */
+	dwc_ddrphy_apb_wr(0x210043, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b0_p2 */
+	dwc_ddrphy_apb_wr(0x210143, 0x581); /*  DWC_DDRPHYA_DBYTE0_DqDqsRcvCntrl_b1_p2 */
+	dwc_ddrphy_apb_wr(0x211043, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b0_p2 */
+	dwc_ddrphy_apb_wr(0x211143, 0x581); /*  DWC_DDRPHYA_DBYTE1_DqDqsRcvCntrl_b1_p2 */
+	dwc_ddrphy_apb_wr(0x212043, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b0_p2 */
+	dwc_ddrphy_apb_wr(0x212143, 0x581); /*  DWC_DDRPHYA_DBYTE2_DqDqsRcvCntrl_b1_p2 */
+	dwc_ddrphy_apb_wr(0x213043, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b0_p2 */
+	dwc_ddrphy_apb_wr(0x213143, 0x581); /*  DWC_DDRPHYA_DBYTE3_DqDqsRcvCntrl_b1_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming DfiFreqRatio_p0 to 0x1 */
+	dwc_ddrphy_apb_wr(0x200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming DfiFreqRatio_p1 to 0x1 */
+	dwc_ddrphy_apb_wr(0x1200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming DfiFreqRatio_p2 to 0x1 */
+	dwc_ddrphy_apb_wr(0x2200fa, 0x1); /*  DWC_DDRPHYA_MASTER0_DfiFreqRatio_p2 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TristateModeCA::DisDynAdrTri_p0 to 0x1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=0, Memclk=800MHz, Programming TristateModeCA::DDR2TMode_p0 to 0x0 */
+	dwc_ddrphy_apb_wr(0x20019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p0 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TristateModeCA::DisDynAdrTri_p1 to 0x1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=1, Memclk=266MHz, Programming TristateModeCA::DDR2TMode_p1 to 0x0 */
+	dwc_ddrphy_apb_wr(0x120019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TristateModeCA::DisDynAdrTri_p2 to 0x1 */
+	/*  [phyinit_C_initPhyConfig] Pstate=2, Memclk=166MHz, Programming TristateModeCA::DDR2TMode_p2 to 0x0 */
+	dwc_ddrphy_apb_wr(0x220019, 0x5); /*  DWC_DDRPHYA_MASTER0_TristateModeCA_p2 */
+	/*  [phyinit_C_initPhyConfig] Programming DfiFreqXlat* */
+	dwc_ddrphy_apb_wr(0x200f0, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat0 */
+	dwc_ddrphy_apb_wr(0x200f1, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat1 */
+	dwc_ddrphy_apb_wr(0x200f2, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat2 */
+	dwc_ddrphy_apb_wr(0x200f3, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat3 */
+	dwc_ddrphy_apb_wr(0x200f4, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat4 */
+	dwc_ddrphy_apb_wr(0x200f5, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat5 */
+	dwc_ddrphy_apb_wr(0x200f6, 0x5555); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat6 */
+	dwc_ddrphy_apb_wr(0x200f7, 0xf000); /*  DWC_DDRPHYA_MASTER0_DfiFreqXlat7 */
+	/*  [phyinit_C_initPhyConfig] Programming MasterX4Config::X4TG to 0x0 */
+	dwc_ddrphy_apb_wr(0x20025, 0x0); /*  DWC_DDRPHYA_MASTER0_MasterX4Config */
+	/*  [phyinit_C_initPhyConfig] End of dwc_ddrphy_phyinit_C_initPhyConfig() */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  dwc_ddrphy_phyihunit_userCustom_customPreTrain is a user-editable function. */
+	/*  */
+	/*  See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  [phyinit_userCustom_customPreTrain] Start of dwc_ddrphy_phyinit_userCustom_customPreTrain() */
+	/*  [phyinit_userCustom_customPreTrain] End of dwc_ddrphy_phyinit_userCustom_customPreTrain() */
+	/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] Start of dwc_ddrphy_phyinit_D_loadIMEM (Train2D=0) */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  (D) Load the 1D IMEM image */
+	/*  */
+	/*  This function loads the training firmware IMEM image into the SRAM. */
+	/*  See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  */
+	/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] Programming MemResetL to 0x2 */
+	if (!after_retention) {
+		dwc_ddrphy_apb_wr(0x20060, 0x2);
+
+		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_imem.incv */
+
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x50000 size 0x4000 */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x4000 */
+		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		/*       This allows the firmware unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_D_loadIMEM, 1D] End of dwc_ddrphy_phyinit_D_loadIMEM() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 0 */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (0);
+
+		/*  */
+		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
+		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=0, Train2D=0) */
+
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  for test on silicon, load 1D dmem/imem here */
+#ifdef CONFIG_SPL_VSI_FW_LOADING
+		load_train_1d_code();
+#else
+		ddr_load_train_code(FW_1D_IMAGE);
+#endif
+		ddr_dbg("start 1d train\n");
+
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
+
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x54000, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54000, 0x600);
+#endif
+		dwc_ddrphy_apb_wr(0x54001, 0x0);
+		dwc_ddrphy_apb_wr(0x54002, 0x0);
+		dwc_ddrphy_apb_wr(0x54003, 0x640);
+		dwc_ddrphy_apb_wr(0x54004, 0x2);
+		dwc_ddrphy_apb_wr(0x54005, 0x0);
+		dwc_ddrphy_apb_wr(0x54006, 0x140);
+		dwc_ddrphy_apb_wr(0x54007, 0x2000);
+#ifdef DDR_ONE_RANK
+		dwc_ddrphy_apb_wr(0x54008, 0x101);
+		dwc_ddrphy_apb_wr(0x54009, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54008, 0x303);
+		dwc_ddrphy_apb_wr(0x54009, 0x200);
+#endif
+		dwc_ddrphy_apb_wr(0x5400a, 0x0);
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x5400b, 0x31f);
+#else
+		dwc_ddrphy_apb_wr(0x5400b, 0x1);
+#endif
+		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
+		dwc_ddrphy_apb_wr(0x5400d, 0x0);
+		dwc_ddrphy_apb_wr(0x5400e, 0x0);
+		dwc_ddrphy_apb_wr(0x5400f, 0x0);
+		dwc_ddrphy_apb_wr(0x54010, 0x0);
+		dwc_ddrphy_apb_wr(0x54011, 0x0);
+		dwc_ddrphy_apb_wr(0x54012, 0x1);
+		dwc_ddrphy_apb_wr(0x5402f, 0xd70);
+		dwc_ddrphy_apb_wr(0x54030, 0x4);
+		dwc_ddrphy_apb_wr(0x54031, 0x18);
+		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
+		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
+		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		/*       This allows the firmware unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (G) Execute the Training Firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
+		/*      ResetToMicro fields to 1 (all other fields should be zero). */
+		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
+		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
+		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
+
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
+		/*  4.   Halt the microcontroller." */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (H) Read the Message Block results */
+		/*  */
+		/*  The procedure is as follows: */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  */
+		/*  2. Read the Firmware Message Block to obtain the results from the training. */
+		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
+		/*  Example: */
+		/*  if (Train2D) */
+		/*  { */
+		/*    _read_2d_message_block_outputs_ */
+		/*  } */
+		/*  else */
+		/*  { */
+		/*    _read_1d_message_block_outputs_ */
+		/*  } */
+		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
+
+		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
+		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
+		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 1 */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+#ifdef DDR3_SW_FFC
+		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (1);
+
+		/*  */
+		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
+		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=1, Train2D=0) */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
+
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x54000, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54000, 0x600);
+#endif
+		dwc_ddrphy_apb_wr(0x54001, 0x0);
+		dwc_ddrphy_apb_wr(0x54002, 0x1);
+		dwc_ddrphy_apb_wr(0x54003, 0x214);
+		dwc_ddrphy_apb_wr(0x54004, 0x2);
+		dwc_ddrphy_apb_wr(0x54005, 0x0);
+		dwc_ddrphy_apb_wr(0x54006, 0x140);
+		dwc_ddrphy_apb_wr(0x54007, 0x2000);
+#ifdef DDR_ONE_RANK
+		dwc_ddrphy_apb_wr(0x54008, 0x101);
+		dwc_ddrphy_apb_wr(0x54009, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54008, 0x303);
+		dwc_ddrphy_apb_wr(0x54009, 0x200);
+#endif
+		dwc_ddrphy_apb_wr(0x5400a, 0x0);
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x5400b, 0x21f);
+#else
+		dwc_ddrphy_apb_wr(0x5400b, 0x1);
+#endif
+		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
+		dwc_ddrphy_apb_wr(0x5400d, 0x0);
+		dwc_ddrphy_apb_wr(0x5400e, 0x0);
+		dwc_ddrphy_apb_wr(0x5400f, 0x0);
+		dwc_ddrphy_apb_wr(0x54010, 0x0);
+		dwc_ddrphy_apb_wr(0x54011, 0x0);
+		dwc_ddrphy_apb_wr(0x54012, 0x1);
+		dwc_ddrphy_apb_wr(0x5402f, 0x930);
+		dwc_ddrphy_apb_wr(0x54030, 0x4);
+		dwc_ddrphy_apb_wr(0x54031, 0x8);
+		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
+		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
+		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		/*       This allows the firmware unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (G) Execute the Training Firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
+		/*      ResetToMicro fields to 1 (all other fields should be zero). */
+		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
+		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
+		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
+
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
+		/*  4.   Halt the microcontroller." */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (H) Read the Message Block results */
+		/*  */
+		/*  The procedure is as follows: */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  */
+		/*  2. Read the Firmware Message Block to obtain the results from the training. */
+		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
+		/*  Example: */
+		/*  if (Train2D) */
+		/*  { */
+		/*    _read_2d_message_block_outputs_ */
+		/*  } */
+		/*  else */
+		/*  { */
+		/*    _read_1d_message_block_outputs_ */
+		/*  } */
+		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
+
+		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
+		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
+		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  Step (E) Set the PHY input clocks to the desired frequency for pstate 2 */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		dwc_ddrphy_phyinit_userCustom_E_setDfiClk (2);
+
+		/*  */
+		/*  [dwc_ddrphy_phyinit_userCustom_E_setDfiClk] End of dwc_ddrphy_phyinit_userCustom_E_setDfiClk() */
+		/*  [phyinit_F_loadDMEM, 1D] Start of dwc_ddrphy_phyinit_F_loadDMEM (pstate=2, Train2D=0) */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (F) Load the 1D DMEM image and write the 1D Message Block parameters for the training firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  [dwc_ddrphy_phyinit_storeIncvFile] Reading input file: ../../../../firmware/A-2017.09/ddr3/ddr3_pmu_train_dmem.incv */
+
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		/*        This allows the memory controller unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] STARTING. offset 0x54000 size 0x36a */
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x54000, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54000, 0x600);
+#endif
+		dwc_ddrphy_apb_wr(0x54001, 0x0);
+		dwc_ddrphy_apb_wr(0x54002, 0x2);
+		dwc_ddrphy_apb_wr(0x54003, 0x14c);
+		dwc_ddrphy_apb_wr(0x54004, 0x2);
+		dwc_ddrphy_apb_wr(0x54005, 0x0);
+		dwc_ddrphy_apb_wr(0x54006, 0x140);
+		dwc_ddrphy_apb_wr(0x54007, 0x2000);
+#ifdef DDR_ONE_RANK
+		dwc_ddrphy_apb_wr(0x54008, 0x101);
+		dwc_ddrphy_apb_wr(0x54009, 0x0);
+#else
+		dwc_ddrphy_apb_wr(0x54008, 0x303);
+		dwc_ddrphy_apb_wr(0x54009, 0x200);
+#endif
+		dwc_ddrphy_apb_wr(0x5400a, 0x0);
+#ifdef RUN_ON_SILICON
+		dwc_ddrphy_apb_wr(0x5400b, 0x21f);
+#else
+		dwc_ddrphy_apb_wr(0x5400b, 0x1);
+#endif
+		dwc_ddrphy_apb_wr(0x5400c, 0xc8);
+		dwc_ddrphy_apb_wr(0x5400d, 0x0);
+		dwc_ddrphy_apb_wr(0x5400e, 0x0);
+		dwc_ddrphy_apb_wr(0x5400f, 0x0);
+		dwc_ddrphy_apb_wr(0x54010, 0x0);
+		dwc_ddrphy_apb_wr(0x54011, 0x0);
+		dwc_ddrphy_apb_wr(0x54012, 0x1);
+		dwc_ddrphy_apb_wr(0x5402f, 0x520);
+		dwc_ddrphy_apb_wr(0x54030, 0x4);
+		dwc_ddrphy_apb_wr(0x54031, 0x0);
+		dwc_ddrphy_apb_wr(0x5403a, 0x1221);
+		dwc_ddrphy_apb_wr(0x5403b, 0x4884);
+		/*  [dwc_ddrphy_phyinit_WriteOutMem] DONE.  Index 0x36a */
+		/*  2.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		/*       This allows the firmware unrestricted access to the configuration CSRs. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  [phyinit_F_loadDMEM, 1D] End of dwc_ddrphy_phyinit_F_loadDMEM() */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (G) Execute the Training Firmware */
+		/*  */
+		/*  See PhyInit App Note for detailed description and function usage */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.  Reset the firmware microcontroller by writing the MicroReset CSR to set the StallToMicro and */
+		/*      ResetToMicro fields to 1 (all other fields should be zero). */
+		/*      Then rewrite the CSR so that only the StallToMicro remains set (all other fields should be zero). */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		dwc_ddrphy_apb_wr(0xd0099, 0x9); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  2. Begin execution of the training firmware by setting the MicroReset CSR to 4'b0000. */
+		dwc_ddrphy_apb_wr(0xd0099, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  */
+		/*  3.   Wait for the training firmware to complete by following the procedure in "uCtrl Initialization and Mailbox Messaging" */
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] Wait for the training firmware to complete.  Implement timeout fucntion or follow the procedure in "3.4 Running the firmware" of the Training Firmware Application Note to poll the Mailbox message. */
+		dwc_ddrphy_phyinit_userCustom_G_waitFwDone ();
+
+		/*  [dwc_ddrphy_phyinit_userCustom_G_waitFwDone] End of dwc_ddrphy_phyinit_userCustom_G_waitFwDone() */
+		/*  4.   Halt the microcontroller." */
+		dwc_ddrphy_apb_wr(0xd0099, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroReset */
+		/*  [dwc_ddrphy_phyinit_G_execFW] End of dwc_ddrphy_phyinit_G_execFW () */
+		/*  */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  (H) Read the Message Block results */
+		/*  */
+		/*  The procedure is as follows: */
+		/*  */
+		/* ############################################################## */
+		/*  */
+		/*  */
+		/*  1.	Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  */
+		/*  2. Read the Firmware Message Block to obtain the results from the training. */
+		/*  This can be accomplished by issuing APB read commands to the DMEM addresses. */
+		/*  Example: */
+		/*  if (Train2D) */
+		/*  { */
+		/*    _read_2d_message_block_outputs_ */
+		/*  } */
+		/*  else */
+		/*  { */
+		/*    _read_1d_message_block_outputs_ */
+		/*  } */
+		dwc_ddrphy_phyinit_userCustom_H_readMsgBlock (0);
+
+		/*  [dwc_ddrphy_phyinit_userCustom_H_readMsgBlock] End of dwc_ddrphy_phyinit_userCustom_H_readMsgBlock () */
+		/*  3.	Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+		dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+		/*  4.	If training is required at another frequency, repeat the operations starting at step (E). */
+		/*  [dwc_ddrphy_phyinit_H_readMsgBlock] End of dwc_ddrphy_phyinit_H_readMsgBlock() */
+		/*  [phyinit_I_loadPIEImage] Start of dwc_ddrphy_phyinit_I_loadPIEImage() */
+#endif /*  DDR3_SW_FFC */
+		ddr_dbg("1D training done!!!!\n");
+	} /* !after_retention */else {/* after_retention */
+		/* restore_1d2d_trained_csr_ddr3_p0(SAVE_DDRPHY_TRAIN_ADDR); */
+		restore_1d2d_trained_csr_ddr3_p012(SAVE_DDRPHY_TRAIN_ADDR);
+	} /* after_retention */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  (I) Load PHY Init Engine Image */
+	/*  */
+	/*  Load the PHY Initialization Engine memory with the provided initialization sequence. */
+	/*  See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  */
+	/*  Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0. */
+	/*  This allows the memory controller unrestricted access to the configuration CSRs. */
+	dwc_ddrphy_apb_wr(0xd0000, 0x0); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	/*  [phyinit_I_loadPIEImage] Programming PIE Production Code */
+	dwc_ddrphy_apb_wr(0x90000, 0x10); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s0 */
+	dwc_ddrphy_apb_wr(0x90001, 0x400); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s1 */
+	dwc_ddrphy_apb_wr(0x90002, 0x10e); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b0s2 */
+	dwc_ddrphy_apb_wr(0x90003, 0x0); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s0 */
+	dwc_ddrphy_apb_wr(0x90004, 0x0); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s1 */
+	dwc_ddrphy_apb_wr(0x90005, 0x8); /*  DWC_DDRPHYA_INITENG0_PreSequenceReg0b1s2 */
+	dwc_ddrphy_apb_wr(0x90029, 0xb); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s0 */
+	dwc_ddrphy_apb_wr(0x9002a, 0x480); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s1 */
+	dwc_ddrphy_apb_wr(0x9002b, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b0s2 */
+	dwc_ddrphy_apb_wr(0x9002c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s0 */
+	dwc_ddrphy_apb_wr(0x9002d, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s1 */
+	dwc_ddrphy_apb_wr(0x9002e, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b1s2 */
+	dwc_ddrphy_apb_wr(0x9002f, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s0 */
+	dwc_ddrphy_apb_wr(0x90030, 0x478); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s1 */
+	dwc_ddrphy_apb_wr(0x90031, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b2s2 */
+	dwc_ddrphy_apb_wr(0x90032, 0x2); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s0 */
+	dwc_ddrphy_apb_wr(0x90033, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s1 */
+	dwc_ddrphy_apb_wr(0x90034, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b3s2 */
+	dwc_ddrphy_apb_wr(0x90035, 0xf); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s0 */
+	dwc_ddrphy_apb_wr(0x90036, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s1 */
+	dwc_ddrphy_apb_wr(0x90037, 0x139); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b4s2 */
+	dwc_ddrphy_apb_wr(0x90038, 0x44); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s0 */
+	dwc_ddrphy_apb_wr(0x90039, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s1 */
+	dwc_ddrphy_apb_wr(0x9003a, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b5s2 */
+	dwc_ddrphy_apb_wr(0x9003b, 0x14f); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s0 */
+	dwc_ddrphy_apb_wr(0x9003c, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s1 */
+	dwc_ddrphy_apb_wr(0x9003d, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b6s2 */
+	dwc_ddrphy_apb_wr(0x9003e, 0x47); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s0 */
+	dwc_ddrphy_apb_wr(0x9003f, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s1 */
+	dwc_ddrphy_apb_wr(0x90040, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b7s2 */
+	dwc_ddrphy_apb_wr(0x90041, 0x4f); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s0 */
+	dwc_ddrphy_apb_wr(0x90042, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s1 */
+	dwc_ddrphy_apb_wr(0x90043, 0x179); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b8s2 */
+	dwc_ddrphy_apb_wr(0x90044, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s0 */
+	dwc_ddrphy_apb_wr(0x90045, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s1 */
+	dwc_ddrphy_apb_wr(0x90046, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b9s2 */
+	dwc_ddrphy_apb_wr(0x90047, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s0 */
+	dwc_ddrphy_apb_wr(0x90048, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s1 */
+	dwc_ddrphy_apb_wr(0x90049, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b10s2 */
+	dwc_ddrphy_apb_wr(0x9004a, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s0 */
+	dwc_ddrphy_apb_wr(0x9004b, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s1 */
+	dwc_ddrphy_apb_wr(0x9004c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b11s2 */
+	dwc_ddrphy_apb_wr(0x9004d, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s0 */
+	dwc_ddrphy_apb_wr(0x9004e, 0x45a); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s1 */
+	dwc_ddrphy_apb_wr(0x9004f, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b12s2 */
+	dwc_ddrphy_apb_wr(0x90050, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s0 */
+	dwc_ddrphy_apb_wr(0x90051, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s1 */
+	dwc_ddrphy_apb_wr(0x90052, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b13s2 */
+	dwc_ddrphy_apb_wr(0x90053, 0x40); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s0 */
+	dwc_ddrphy_apb_wr(0x90054, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s1 */
+	dwc_ddrphy_apb_wr(0x90055, 0x179); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b14s2 */
+	dwc_ddrphy_apb_wr(0x90056, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s0 */
+	dwc_ddrphy_apb_wr(0x90057, 0x618); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s1 */
+	dwc_ddrphy_apb_wr(0x90058, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b15s2 */
+	dwc_ddrphy_apb_wr(0x90059, 0x40c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s0 */
+	dwc_ddrphy_apb_wr(0x9005a, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s1 */
+	dwc_ddrphy_apb_wr(0x9005b, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b16s2 */
+	dwc_ddrphy_apb_wr(0x9005c, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s0 */
+	dwc_ddrphy_apb_wr(0x9005d, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s1 */
+	dwc_ddrphy_apb_wr(0x9005e, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b17s2 */
+	dwc_ddrphy_apb_wr(0x9005f, 0x4040); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s0 */
+	dwc_ddrphy_apb_wr(0x90060, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s1 */
+	dwc_ddrphy_apb_wr(0x90061, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b18s2 */
+	dwc_ddrphy_apb_wr(0x90062, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s0 */
+	dwc_ddrphy_apb_wr(0x90063, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s1 */
+	dwc_ddrphy_apb_wr(0x90064, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b19s2 */
+	dwc_ddrphy_apb_wr(0x90065, 0x40); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s0 */
+	dwc_ddrphy_apb_wr(0x90066, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s1 */
+	dwc_ddrphy_apb_wr(0x90067, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b20s2 */
+	dwc_ddrphy_apb_wr(0x90068, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s0 */
+	dwc_ddrphy_apb_wr(0x90069, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s1 */
+	dwc_ddrphy_apb_wr(0x9006a, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b21s2 */
+	dwc_ddrphy_apb_wr(0x9006b, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s0 */
+	dwc_ddrphy_apb_wr(0x9006c, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s1 */
+	dwc_ddrphy_apb_wr(0x9006d, 0x78); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b22s2 */
+	dwc_ddrphy_apb_wr(0x9006e, 0x549); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s0 */
+	dwc_ddrphy_apb_wr(0x9006f, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s1 */
+	dwc_ddrphy_apb_wr(0x90070, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b23s2 */
+	dwc_ddrphy_apb_wr(0x90071, 0xd49); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s0 */
+	dwc_ddrphy_apb_wr(0x90072, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s1 */
+	dwc_ddrphy_apb_wr(0x90073, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b24s2 */
+	dwc_ddrphy_apb_wr(0x90074, 0x94a); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s0 */
+	dwc_ddrphy_apb_wr(0x90075, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s1 */
+	dwc_ddrphy_apb_wr(0x90076, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b25s2 */
+	dwc_ddrphy_apb_wr(0x90077, 0x441); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s0 */
+	dwc_ddrphy_apb_wr(0x90078, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s1 */
+	dwc_ddrphy_apb_wr(0x90079, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b26s2 */
+	dwc_ddrphy_apb_wr(0x9007a, 0x42); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s0 */
+	dwc_ddrphy_apb_wr(0x9007b, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s1 */
+	dwc_ddrphy_apb_wr(0x9007c, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b27s2 */
+	dwc_ddrphy_apb_wr(0x9007d, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s0 */
+	dwc_ddrphy_apb_wr(0x9007e, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s1 */
+	dwc_ddrphy_apb_wr(0x9007f, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b28s2 */
+	dwc_ddrphy_apb_wr(0x90080, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s0 */
+	dwc_ddrphy_apb_wr(0x90081, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s1 */
+	dwc_ddrphy_apb_wr(0x90082, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b29s2 */
+	dwc_ddrphy_apb_wr(0x90083, 0xa); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s0 */
+	dwc_ddrphy_apb_wr(0x90084, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s1 */
+	dwc_ddrphy_apb_wr(0x90085, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b30s2 */
+	dwc_ddrphy_apb_wr(0x90086, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s0 */
+	dwc_ddrphy_apb_wr(0x90087, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s1 */
+	dwc_ddrphy_apb_wr(0x90088, 0x149); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b31s2 */
+	dwc_ddrphy_apb_wr(0x90089, 0x9); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s0 */
+	dwc_ddrphy_apb_wr(0x9008a, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s1 */
+	dwc_ddrphy_apb_wr(0x9008b, 0x159); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b32s2 */
+	dwc_ddrphy_apb_wr(0x9008c, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s0 */
+	dwc_ddrphy_apb_wr(0x9008d, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s1 */
+	dwc_ddrphy_apb_wr(0x9008e, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b33s2 */
+	dwc_ddrphy_apb_wr(0x9008f, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s0 */
+	dwc_ddrphy_apb_wr(0x90090, 0x3c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s1 */
+	dwc_ddrphy_apb_wr(0x90091, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b34s2 */
+	dwc_ddrphy_apb_wr(0x90092, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s0 */
+	dwc_ddrphy_apb_wr(0x90093, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s1 */
+	dwc_ddrphy_apb_wr(0x90094, 0x48); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b35s2 */
+	dwc_ddrphy_apb_wr(0x90095, 0x18); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s0 */
+	dwc_ddrphy_apb_wr(0x90096, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s1 */
+	dwc_ddrphy_apb_wr(0x90097, 0x58); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b36s2 */
+	dwc_ddrphy_apb_wr(0x90098, 0xa); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s0 */
+	dwc_ddrphy_apb_wr(0x90099, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s1 */
+	dwc_ddrphy_apb_wr(0x9009a, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b37s2 */
+	dwc_ddrphy_apb_wr(0x9009b, 0x2); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s0 */
+	dwc_ddrphy_apb_wr(0x9009c, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s1 */
+	dwc_ddrphy_apb_wr(0x9009d, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b38s2 */
+	dwc_ddrphy_apb_wr(0x9009e, 0x7); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s0 */
+	dwc_ddrphy_apb_wr(0x9009f, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s1 */
+	dwc_ddrphy_apb_wr(0x900a0, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b39s2 */
+	dwc_ddrphy_apb_wr(0x900a1, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s0 */
+	dwc_ddrphy_apb_wr(0x900a2, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s1 */
+	dwc_ddrphy_apb_wr(0x900a3, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b40s2 */
+	dwc_ddrphy_apb_wr(0x900a4, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s0 */
+	dwc_ddrphy_apb_wr(0x900a5, 0x8140); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s1 */
+	dwc_ddrphy_apb_wr(0x900a6, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b41s2 */
+	dwc_ddrphy_apb_wr(0x900a7, 0x10); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s0 */
+	dwc_ddrphy_apb_wr(0x900a8, 0x8138); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s1 */
+	dwc_ddrphy_apb_wr(0x900a9, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b42s2 */
+	dwc_ddrphy_apb_wr(0x900aa, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s0 */
+	dwc_ddrphy_apb_wr(0x900ab, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s1 */
+	dwc_ddrphy_apb_wr(0x900ac, 0x101); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b43s2 */
+	dwc_ddrphy_apb_wr(0x900ad, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s0 */
+	dwc_ddrphy_apb_wr(0x900ae, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s1 */
+	dwc_ddrphy_apb_wr(0x900af, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b44s2 */
+	dwc_ddrphy_apb_wr(0x900b0, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s0 */
+	dwc_ddrphy_apb_wr(0x900b1, 0x448); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s1 */
+	dwc_ddrphy_apb_wr(0x900b2, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b45s2 */
+	dwc_ddrphy_apb_wr(0x900b3, 0xf); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s0 */
+	dwc_ddrphy_apb_wr(0x900b4, 0x7c0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s1 */
+	dwc_ddrphy_apb_wr(0x900b5, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b46s2 */
+	dwc_ddrphy_apb_wr(0x900b6, 0x47); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s0 */
+	dwc_ddrphy_apb_wr(0x900b7, 0x630); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s1 */
+	dwc_ddrphy_apb_wr(0x900b8, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b47s2 */
+	dwc_ddrphy_apb_wr(0x900b9, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s0 */
+	dwc_ddrphy_apb_wr(0x900ba, 0x618); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s1 */
+	dwc_ddrphy_apb_wr(0x900bb, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b48s2 */
+	dwc_ddrphy_apb_wr(0x900bc, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s0 */
+	dwc_ddrphy_apb_wr(0x900bd, 0xe0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s1 */
+	dwc_ddrphy_apb_wr(0x900be, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b49s2 */
+	dwc_ddrphy_apb_wr(0x900bf, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s0 */
+	dwc_ddrphy_apb_wr(0x900c0, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s1 */
+	dwc_ddrphy_apb_wr(0x900c1, 0x109); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b50s2 */
+	dwc_ddrphy_apb_wr(0x900c2, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s0 */
+	dwc_ddrphy_apb_wr(0x900c3, 0x8140); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s1 */
+	dwc_ddrphy_apb_wr(0x900c4, 0x10c); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b51s2 */
+	dwc_ddrphy_apb_wr(0x900c5, 0x0); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s0 */
+	dwc_ddrphy_apb_wr(0x900c6, 0x1); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s1 */
+	dwc_ddrphy_apb_wr(0x900c7, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b52s2 */
+	dwc_ddrphy_apb_wr(0x900c8, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s0 */
+	dwc_ddrphy_apb_wr(0x900c9, 0x4); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s1 */
+	dwc_ddrphy_apb_wr(0x900ca, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b53s2 */
+	dwc_ddrphy_apb_wr(0x900cb, 0x8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s0 */
+	dwc_ddrphy_apb_wr(0x900cc, 0x7c8); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s1 */
+	dwc_ddrphy_apb_wr(0x900cd, 0x101); /*  DWC_DDRPHYA_INITENG0_SequenceReg0b54s2 */
+	dwc_ddrphy_apb_wr(0x90006, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s0 */
+	dwc_ddrphy_apb_wr(0x90007, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s1 */
+	dwc_ddrphy_apb_wr(0x90008, 0x8); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b0s2 */
+	dwc_ddrphy_apb_wr(0x90009, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s0 */
+	dwc_ddrphy_apb_wr(0x9000a, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s1 */
+	dwc_ddrphy_apb_wr(0x9000b, 0x0); /*  DWC_DDRPHYA_INITENG0_PostSequenceReg0b1s2 */
+	dwc_ddrphy_apb_wr(0xd00e7, 0x400); /*  DWC_DDRPHYA_APBONLY0_SequencerOverride */
+	dwc_ddrphy_apb_wr(0x90017, 0x0); /*  DWC_DDRPHYA_INITENG0_StartVector0b0 */
+	dwc_ddrphy_apb_wr(0x90026, 0x2c); /*  DWC_DDRPHYA_INITENG0_StartVector0b15 */
+	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY0 to 0x32 */
+	dwc_ddrphy_apb_wr(0x2000b, 0x32); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p0 */
+	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY1 to 0x64 */
+	dwc_ddrphy_apb_wr(0x2000c, 0x64); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p0 */
+	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY2 to 0x3e8 */
+	dwc_ddrphy_apb_wr(0x2000d, 0x3e8); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p0 */
+	/*  [phyinit_I_loadPIEImage] Pstate=0,  Memclk=800MHz, Programming Seq0BDLY3 to 0x2c */
+	dwc_ddrphy_apb_wr(0x2000e, 0x2c); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p0 */
+	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY0 to 0x10 */
+	dwc_ddrphy_apb_wr(0x12000b, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p1 */
+	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY1 to 0x21 */
+	dwc_ddrphy_apb_wr(0x12000c, 0x21); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p1 */
+	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY2 to 0x14c */
+	dwc_ddrphy_apb_wr(0x12000d, 0x14c); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p1 */
+	/*  [phyinit_I_loadPIEImage] Pstate=1,  Memclk=266MHz, Programming Seq0BDLY3 to 0x10 */
+	dwc_ddrphy_apb_wr(0x12000e, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p1 */
+	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY0 to 0xa */
+	dwc_ddrphy_apb_wr(0x22000b, 0xa); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY0_p2 */
+	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY1 to 0x14 */
+	dwc_ddrphy_apb_wr(0x22000c, 0x14); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY1_p2 */
+	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY2 to 0xcf */
+	dwc_ddrphy_apb_wr(0x22000d, 0xcf); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY2_p2 */
+	/*  [phyinit_I_loadPIEImage] Pstate=2,  Memclk=166MHz, Programming Seq0BDLY3 to 0x10 */
+	dwc_ddrphy_apb_wr(0x22000e, 0x10); /*  DWC_DDRPHYA_MASTER0_Seq0BDLY3_p2 */
+	dwc_ddrphy_apb_wr(0x9000c, 0x0); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag0 */
+	dwc_ddrphy_apb_wr(0x9000d, 0x173); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag1 */
+	dwc_ddrphy_apb_wr(0x9000e, 0x60); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag2 */
+	dwc_ddrphy_apb_wr(0x9000f, 0x6110); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag3 */
+	dwc_ddrphy_apb_wr(0x90010, 0x2152); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag4 */
+	dwc_ddrphy_apb_wr(0x90011, 0xdfbd); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag5 */
+	dwc_ddrphy_apb_wr(0x90012, 0xffff); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag6 */
+	dwc_ddrphy_apb_wr(0x90013, 0x6152); /*  DWC_DDRPHYA_INITENG0_Seq0BDisableFlag7 */
+	/*  Disabling Ucclk (PMU) and Hclk (training hardware) */
+	dwc_ddrphy_apb_wr(0xc0080, 0x0); /*  DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
+	/*  Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1. */
+	dwc_ddrphy_apb_wr(0xd0000, 0x1); /*  DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	/*  [phyinit_I_loadPIEImage] End of dwc_ddrphy_phyinit_I_loadPIEImage() */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  dwc_ddrphy_phyinit_userCustom_customPostTrain is a user-editable function. */
+	/*  */
+	/*  See PhyInit App Note for detailed description and function usage */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	dwc_ddrphy_phyinit_userCustom_customPostTrain ();
+
+	/*  [dwc_ddrphy_phyinit_userCustom_customPostTrain] End of dwc_ddrphy_phyinit_userCustom_customPostTrain() */
+	/*  [dwc_ddrphy_phyinit_userCustom_J_enterMissionMode] Start of dwc_ddrphy_phyinit_userCustom_J_enterMissionMode() */
+	/*  */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	/*  (J) Initialize the PHY to Mission Mode through DFI Initialization */
+	/*  */
+	/*  Initialize the PHY to mission mode as follows: */
+	/*  */
+	/*  1. Set the PHY input clocks to the desired frequency. */
+	/*  2. Initialize the PHY to mission mode by performing DFI Initialization. */
+	/*     Please see the DFI specification for more information. See the DFI frequency bus encoding in section <XXX>. */
+	/*  Note: The PHY training firmware initializes the DRAM state. if skip */
+	/*  training is used, the DRAM state is not initialized. */
+	/*  */
+	/* ############################################################## */
+	/*  */
+	dwc_ddrphy_phyinit_userCustom_J_enterMissionMode ();
+
+	/*  */
+	/*  [dwc_ddrphy_phyinit_userCustom_J_enterMissionMode] End of dwc_ddrphy_phyinit_userCustom_J_enterMissionMode() */
+	/*  [dwc_ddrphy_phyinit_sequence] End of dwc_ddrphy_phyinit_sequence() */
+	/*  [dwc_ddrphy_phyinit_main] End of dwc_ddrphy_phyinit_main() */
+
+	/* ---------------------------------------------------------------------- */
+	/*   save 1d2d training CSR */
+	/* ---------------------------------------------------------------------- */
+	if (!after_retention) {
+		save_1d2d_trained_csr_ddr3_p012(SAVE_DDRPHY_TRAIN_ADDR);
+	}
+}
diff --git a/board/karo/tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c b/board/karo/tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
new file mode 100644
index 0000000000000000000000000000000000000000..e3875f5a3663f8fa77d277752bebd8ea196206a3
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr3l/ddr3_sw_fast_freq_chg_fw09.c
@@ -0,0 +1,277 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "anamix_common.h"
+#include "ddr3_define.h"
+
+void umctl2_cfg(void)
+{
+#ifdef DDR_ONE_RANK
+	reg32_write(DDRC_MSTR(0), 0x81040001);
+#else
+	reg32_write(DDRC_MSTR(0), 0x83040001);
+#endif
+
+	reg32_write(DDRC_PWRCTL(0), 0x000000a8);
+	reg32_write(DDRC_PWRTMG(0), 0x00532203);
+
+	reg32_write(DDRC_RFSHCTL0(0), 0x00203020);
+	reg32_write(DDRC_RFSHCTL1(0), 0x0001000d);
+	reg32_write(DDRC_RFSHCTL3(0), 0x00000000);
+	reg32_write(DDRC_RFSHTMG(0), 0x0061008c);
+	reg32_write(DDRC_CRCPARCTL0(0), 0x00000000);
+	reg32_write(DDRC_CRCPARCTL1(0), 0x00000000);
+	reg32_write(DDRC_INIT0(0), 0xc0030002);
+	reg32_write(DDRC_INIT1(0), 0x0001000b);
+	reg32_write(DDRC_INIT2(0), 0x00006303);
+	reg32_write(DDRC_INIT3(0), 0x0d700004);/* MR1, MR0 */
+	reg32_write(DDRC_INIT4(0), 0x00180000);/* MR2 */
+	reg32_write(DDRC_INIT5(0), 0x00090071);
+	reg32_write(DDRC_INIT6(0), 0x00000000);
+	reg32_write(DDRC_INIT7(0), 0x00000000);
+	reg32_write(DDRC_DIMMCTL(0), 0x00000032); /* [1] dimm_addr_mirr_en, it will effect the MRS if use umctl2 to initi dram. */
+	reg32_write(DDRC_RANKCTL(0), 0x00000ee5);
+	reg32_write(DDRC_DRAMTMG0(0), 0x0c101a0e);
+	reg32_write(DDRC_DRAMTMG1(0), 0x000a0314);
+	reg32_write(DDRC_DRAMTMG2(0), 0x04060509);
+	reg32_write(DDRC_DRAMTMG3(0), 0x00002006);
+	reg32_write(DDRC_DRAMTMG4(0), 0x06020306);
+	reg32_write(DDRC_DRAMTMG5(0), 0x0b060202);
+	reg32_write(DDRC_DRAMTMG6(0), 0x060a0009);
+	reg32_write(DDRC_DRAMTMG7(0), 0x0000060b);
+	reg32_write(DDRC_DRAMTMG8(0), 0x01017c0a);
+	reg32_write(DDRC_DRAMTMG9(0), 0x4000000e);
+	reg32_write(DDRC_DRAMTMG10(0), 0x00070803);
+	reg32_write(DDRC_DRAMTMG11(0), 0x0101000b);
+	reg32_write(DDRC_DRAMTMG12(0), 0x00000000);
+	reg32_write(DDRC_DRAMTMG13(0), 0x5d000000);
+	reg32_write(DDRC_DRAMTMG14(0), 0x00000b39);
+	reg32_write(DDRC_DRAMTMG15(0), 0x80000000);
+	reg32_write(DDRC_DRAMTMG17(0), 0x00f1006a);
+	reg32_write(DDRC_ZQCTL0(0), 0x50800020);
+	reg32_write(DDRC_ZQCTL1(0), 0x00000070);
+	reg32_write(DDRC_ZQCTL2(0), 0x00000000);
+	reg32_write(DDRC_DFITMG0(0), 0x03868203);
+	reg32_write(DDRC_DFITMG1(0), 0x00020103);
+	reg32_write(DDRC_DFILPCFG0(0), 0x07713021);
+	reg32_write(DDRC_DFILPCFG1(0), 0x00000010);
+	reg32_write(DDRC_DFIUPD0(0), 0xe0400018);
+	reg32_write(DDRC_DFIUPD1(0), 0x0005003c);
+	reg32_write(DDRC_DFIUPD2(0), 0x80000000);
+	reg32_write(DDRC_DFIMISC(0), 0x00000011);
+	reg32_write(DDRC_DFITMG2(0), 0x00000603);
+	reg32_write(DDRC_DFITMG3(0), 0x00000001);
+	reg32_write(DDRC_DBICTL(0), 0x00000001);
+	reg32_write(DDRC_DFIPHYMSTR(0), 0x00000000);
+
+	/*  My test mapping in this test case, for 8Gb,(two 4Gb, x16 DDR3) (col addr:10 bits  row addr: 15 bits  bank addr: 3bits  2 ranks) */
+	/*  MEMC_BURST_LENGTH = 8 */
+	/* ----------------------------------------------------------------------------------------------------------------------------------- */
+	/*  AXI add: 31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13   12  11  10  9   8   7   6   5   4   3   2   1   0 (MEM_DATWIDTH=64) */
+	/*  AXI add: 30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12   11  10  9   8   7   6   5   4   3   2   1   0     (MEM_DATWIDTH=32) *** */
+	/*  AXI add: 29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11   10  9   8   7   6   5   4   3   2   1   0         (MEM_DATWIDTH=16) */
+	/* ----------------------------------------------------------------------------------------------------------------------------------- */
+	/*  HIF add: 28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0   -   -   - */
+	/* ----------------------------------------------------------------------------------------------------------------------------------- */
+	/*  **** for Full DQ bus width (X32) **** */
+	/*           cs  r14 r13 r12 r11 r10 r9  r8  r7  r6  r5  r4  r3  r2  r1  r0  b2  b1  b0  c9  c8  c7  c6  c5  c4  c3  c2  c1  c0 */
+	/* Int base  6   20  19  18  17  16  15  14  13  12  11  10  9   8   7   6   4   3   2    9   8  7   6   5    4   3   2   - */
+	/* p Value   22  7   7   7   7   7   7   7   7   7    7   7  7   7   7   7   8   8   8    0   0  0   0   0    0   0   0   - */
+	/* ----------------------------------------------------------------------------------------------------------------------------------- */
+
+	reg32_write(DDRC_ADDRMAP0(0), 0x00000016); /* [4:0] cs-bit0: 6+22=28; [12:8] cs-bit1: 7+0 */
+	reg32_write(DDRC_ADDRMAP1(0), 0x00080808); /* [5:0] bank b0: 2+8; [13:8] b1: P3+8 ; [21:16] b2: 4+8 */
+	reg32_write(DDRC_ADDRMAP2(0), 0x00000000); /* [3:0] col-b2: 2;  [11:8] col-b3: 3; [19:16] col-b4: 4 ; [27:24] col-b5: 5 */
+	reg32_write(DDRC_ADDRMAP3(0), 0x00000000); /* [3:0] col-b6: 6;  [11:8] col-b7: 7; [19:16] col-b8: 8 ; [27:24] col-b9: 9 */
+	reg32_write(DDRC_ADDRMAP4(0), 0x00001f1f); /* col-b10, col-b11 not used */
+	reg32_write(DDRC_ADDRMAP5(0), 0x07070707); /* [3:0] row-b0: 6;  [11:8] row-b1: 7; [19:16] row-b2_b10 ; [27:24] row-b11: 17 */
+	reg32_write(DDRC_ADDRMAP6(0), 0x0f070707); /* [3:0] row-b12:18; [11:8] row-b13: 19; [19:16] row-b14:20 */
+	reg32_write(DDRC_ADDRMAP7(0), 0x00000f0f);
+	reg32_write(DDRC_ADDRMAP8(0), 0x00000000); /* [5:0] bg-b0; [13:8]bg-b1 */
+	reg32_write(DDRC_ADDRMAP9(0), 0x0a020b06); /*  it's valid only when ADDRMAP5.addrmap_row_b2_10 is set to value 15 */
+	reg32_write(DDRC_ADDRMAP10(0), 0x0a0a0a0a);/*  it's valid only when ADDRMAP5.addrmap_row_b2_10 is set to value 15 */
+	reg32_write(DDRC_ADDRMAP11(0), 0x00000000);
+
+
+	reg32_write(DDRC_ODTCFG(0), 0x041d0f5c);
+	reg32_write(DDRC_ODTMAP(0), 0x00000201);
+	reg32_write(DDRC_SCHED(0), 0x7ab50b07);
+	reg32_write(DDRC_SCHED1(0), 0x00000022);
+	reg32_write(DDRC_PERFHPR1(0), 0x7b00665e);
+	reg32_write(DDRC_PERFLPR1(0), 0x2b00c4e1);
+	reg32_write(DDRC_PERFWR1(0), 0xb700c9fe);
+	reg32_write(DDRC_DBG0(0), 0x00000017);
+	reg32_write(DDRC_DBG1(0), 0x00000000);
+	reg32_write(DDRC_DBGCMD(0), 0x00000000);
+	reg32_write(DDRC_SWCTL(0), 0x00000001);
+	reg32_write(DDRC_POISONCFG(0), 0x00010000);
+	reg32_write(DDRC_PCCFG(0), 0x00000100);
+	reg32_write(DDRC_PCFGR_0(0), 0x00003051);
+	reg32_write(DDRC_PCFGW_0(0), 0x000061d2);
+	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
+	reg32_write(DDRC_PCFGQOS0_0(0), 0x02100b04);
+	reg32_write(DDRC_PCFGQOS1_0(0), 0x003f0353);
+	reg32_write(DDRC_PCFGWQOS0_0(0), 0x00000002);
+	reg32_write(DDRC_PCFGWQOS1_0(0), 0x000005fd);
+}
+
+void umctl2_freq1_cfg(void)
+{
+	reg32_write(DDRC_FREQ1_RFSHCTL0(0), 0x00d19034);
+	reg32_write(DDRC_FREQ1_RFSHTMG(0), 0x0040805e);
+	reg32_write(DDRC_FREQ1_INIT3(0), 0x09300004);
+	reg32_write(DDRC_FREQ1_INIT4(0), 0x00080000);
+	reg32_write(DDRC_FREQ1_INIT6(0), 0x00000000);
+	reg32_write(DDRC_FREQ1_INIT7(0), 0x00000000);
+	reg32_write(DDRC_FREQ1_DRAMTMG0(0), 0x090e110a);
+	reg32_write(DDRC_FREQ1_DRAMTMG1(0), 0x0007020e);
+	reg32_write(DDRC_FREQ1_DRAMTMG2(0), 0x03040407);
+	reg32_write(DDRC_FREQ1_DRAMTMG3(0), 0x00002006);
+	reg32_write(DDRC_FREQ1_DRAMTMG4(0), 0x04020304); /*  tRP=6 --> 7 */
+	reg32_write(DDRC_FREQ1_DRAMTMG5(0), 0x09030202);
+	reg32_write(DDRC_FREQ1_DRAMTMG6(0), 0x0c020000);
+	reg32_write(DDRC_FREQ1_DRAMTMG7(0), 0x00000309);
+	reg32_write(DDRC_FREQ1_DRAMTMG8(0), 0x01010a06);
+	reg32_write(DDRC_FREQ1_DRAMTMG9(0), 0x00000003);
+	reg32_write(DDRC_FREQ1_DRAMTMG10(0), 0x00090906);
+	reg32_write(DDRC_FREQ1_DRAMTMG11(0), 0x01010011);
+	reg32_write(DDRC_FREQ1_DRAMTMG12(0), 0x00000000);
+	reg32_write(DDRC_FREQ1_DRAMTMG13(0), 0x40000000);
+	reg32_write(DDRC_FREQ1_DRAMTMG14(0), 0x000000f3);
+	reg32_write(DDRC_FREQ1_DRAMTMG15(0), 0x80000000);
+	reg32_write(DDRC_FREQ1_DRAMTMG17(0), 0x001a0046);
+	reg32_write(DDRC_FREQ1_ZQCTL0(0),  0x50800020);
+	reg32_write(DDRC_FREQ1_DFITMG0(0), 0x03828201);
+	reg32_write(DDRC_FREQ1_DFITMG1(0), 0x00020103);
+	reg32_write(DDRC_FREQ1_DFITMG2(0), 0x00000201);
+	reg32_write(DDRC_FREQ1_DFITMG3(0), 0x00000001);
+	reg32_write(DDRC_FREQ1_ODTCFG(0),  0x0a1a0768);
+
+}
+
+void umctl2_freq2_cfg(void)
+{
+	reg32_write(DDRC_FREQ2_RFSHCTL0(0), 0x00208014);
+	reg32_write(DDRC_FREQ2_RFSHTMG(0), 0x00308046);
+	reg32_write(DDRC_FREQ2_INIT3(0), 0x05200004);
+	reg32_write(DDRC_FREQ2_INIT4(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_INIT6(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_INIT7(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_DRAMTMG0(0), 0x070a0c07);
+	reg32_write(DDRC_FREQ2_DRAMTMG1(0), 0x0005020b);
+	reg32_write(DDRC_FREQ2_DRAMTMG2(0), 0x03030407);
+	reg32_write(DDRC_FREQ2_DRAMTMG3(0), 0x00002006);
+	reg32_write(DDRC_FREQ2_DRAMTMG4(0), 0x03020204);
+	reg32_write(DDRC_FREQ2_DRAMTMG5(0), 0x04070302);
+	reg32_write(DDRC_FREQ2_DRAMTMG6(0), 0x07080000);
+	reg32_write(DDRC_FREQ2_DRAMTMG7(0), 0x00000704);
+	reg32_write(DDRC_FREQ2_DRAMTMG8(0), 0x02026804);
+	reg32_write(DDRC_FREQ2_DRAMTMG9(0), 0x40000006);
+	reg32_write(DDRC_FREQ2_DRAMTMG10(0), 0x000c0b08);
+	reg32_write(DDRC_FREQ2_DRAMTMG11(0), 0x01010015);
+	reg32_write(DDRC_FREQ2_DRAMTMG12(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_DRAMTMG13(0), 0x51000000);
+	reg32_write(DDRC_FREQ2_DRAMTMG14(0), 0x000002a0);
+	reg32_write(DDRC_FREQ2_DRAMTMG15(0), 0x00000000);
+	reg32_write(DDRC_FREQ2_DRAMTMG17(0), 0x008c0039);
+	reg32_write(DDRC_FREQ2_ZQCTL0(0), 0x50800020);
+	reg32_write(DDRC_FREQ2_DFITMG0(0), 0x03818200);
+	reg32_write(DDRC_FREQ2_DFITMG1(0), 0x00020103);
+	reg32_write(DDRC_FREQ2_DFITMG2(0), 0x00000100);
+	reg32_write(DDRC_FREQ2_DFITMG3(0), 0x00000001);
+	reg32_write(DDRC_FREQ2_ODTCFG(0), 0x04050800);
+
+}
+
+void ddr3_pub_train(void)
+{
+	volatile unsigned int tmp_t;
+
+	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F00003F); /*  assert [0]ddr1_preset_n, [1]ddr1_core_reset_n, [2]ddr1_phy_reset, [3]ddr1_phy_pwrokin_n, [4]src_system_rst_b! */
+	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F00000F); /*  deassert [4]src_system_rst_b! */
+
+	/* change the clock source of dram_apb_clk_root */
+	clock_set_target_val(DRAM_APB_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(4) | CLK_ROOT_PRE_DIV(CLK_ROOT_PRE_DIV4)); /* to source 4 --800MHz/4 */
+
+	dram_pll_init(DRAM_PLL_OUT_400M);
+	ddr_dbg("C: dram pll init finished\n");
+
+	reg32_write(0x303A00EC, 0x0000ffff); /* PGC_CPU_MAPPING */
+	reg32setbit(0x303A00F8, 5);/* PU_PGC_SW_PUP_REQ */
+
+	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F000006); /*  release [0]ddr1_preset_n, [3]ddr1_phy_pwrokin_n */
+
+	reg32_write(DDRC_DBG1(0), 0x00000001);
+	reg32_write(DDRC_PWRCTL(0), 0x00000001);
+
+	while (0 != (0x3 & reg32_read(DDRC_STAT(0))))
+		;
+
+	ddr_dbg("C: cfg umctl2 regs ...\n");
+	umctl2_cfg();
+#ifdef DDR3_SW_FFC
+	umctl2_freq1_cfg();
+	umctl2_freq2_cfg();
+#endif
+
+	reg32_write(DDRC_RFSHCTL3(0), 0x00000011);
+	/* RESET: <ctn> DEASSERTED */
+	/* RESET: <a Port 0  DEASSERTED(0) */
+	reg32_write(SRC_DDRC_RCR_ADDR, 0x8F000000); /*  release all reset */
+
+	reg32_write(DDRC_DBG1(0), 0x00000000);
+	reg32_write(DDRC_PWRCTL(0), 0x00000a8);
+	reg32_write(DDRC_SWCTL(0), 0x00000000);
+
+	reg32_write(DDRC_DFIMISC(0), 0x00000000);
+
+	ddr_dbg("C: phy training ...\n");
+	ddr3_phyinit_train_sw_ffc(0);
+
+	do {
+		tmp_t = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x00020097);
+		ddr_dbg("C: Waiting CalBusy value = 0\n");
+	} while (tmp_t != 0);
+
+	reg32_write(DDRC_DFIMISC(0), 0x00000020);
+
+	/*  wait DFISTAT.dfi_init_complete to 1 */
+	while (0 == (0x1 & reg32_read(DDRC_DFISTAT(0))))
+		;
+
+	/*  clear DFIMISC.dfi_init_complete_en */
+	reg32_write(DDRC_DFIMISC(0), 0x00000000);
+	/*  set DFIMISC.dfi_init_complete_en again */
+	reg32_write(DDRC_DFIMISC(0), 0x00000001);
+	reg32_write(DDRC_PWRCTL(0), 0x0000088);
+
+	/*  set SWCTL.sw_done to enable quasi-dynamic register programming outside reset. */
+	reg32_write(DDRC_SWCTL(0), 0x00000001);
+	/* wait SWSTAT.sw_done_ack to 1 */
+	while (0 == (0x1 & reg32_read(DDRC_SWSTAT(0))))
+		;
+
+	/* wait STAT to normal state */
+	while (0x1 != (0x3 & reg32_read(DDRC_STAT(0))))
+		;
+
+	reg32_write(DDRC_PWRCTL(0), 0x0000088);
+
+	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
+	reg32_write(DDRC_RFSHCTL3(0), 0x00000010); /*  dis_auto-refresh is set to 0 */
+
+ }
+
+void ddr_init(void)
+{
+	/* initialize DDR4-2400 (umctl2@800MHz) */
+	ddr3_pub_train();
+}
diff --git a/board/karo/tx8mm/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c b/board/karo/tx8mm/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
new file mode 100644
index 0000000000000000000000000000000000000000..f01ed9f69bab5f46d299a68278adf2617d8519f5
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr3l/restore_1d2d_trained_csr_ddr3_p012.c
@@ -0,0 +1,969 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "../ddr.h"
+#include "ddr3_define.h"
+
+static const unsigned int restore_csr[] = {
+	0x200b2,
+	0x1200b2,
+	0x2200b2,
+	0x200cb,
+#ifdef RUN_ON_SILICON
+	0x10043,
+	0x110043,
+	0x210043,
+	0x10143,
+	0x110143,
+	0x210143,
+	0x11043,
+	0x111043,
+	0x211043,
+	0x11143,
+	0x111143,
+	0x211143,
+	0x12043,
+	0x112043,
+	0x212043,
+	0x12143,
+	0x112143,
+	0x212143,
+	0x13043,
+	0x113043,
+	0x213043,
+	0x13143,
+	0x113143,
+	0x213143,
+	0x80,
+	0x100080,
+	0x200080,
+	0x1080,
+	0x101080,
+	0x201080,
+	0x2080,
+	0x102080,
+	0x202080,
+	0x3080,
+	0x103080,
+	0x203080,
+	0x4080,
+	0x104080,
+	0x204080,
+	0x5080,
+	0x105080,
+	0x205080,
+	0x6080,
+	0x106080,
+	0x206080,
+	0x7080,
+	0x107080,
+	0x207080,
+	0x8080,
+	0x108080,
+	0x208080,
+	0x9080,
+	0x109080,
+	0x209080,
+	0x10080,
+	0x110080,
+	0x210080,
+	0x10180,
+	0x110180,
+	0x210180,
+	0x10081,
+	0x110081,
+	0x210081,
+	0x10181,
+	0x110181,
+	0x210181,
+	0x10082,
+	0x110082,
+	0x210082,
+	0x10182,
+	0x110182,
+	0x210182,
+	0x10083,
+	0x110083,
+	0x210083,
+	0x10183,
+	0x110183,
+	0x210183,
+	0x11080,
+	0x111080,
+	0x211080,
+	0x11180,
+	0x111180,
+	0x211180,
+	0x11081,
+	0x111081,
+	0x211081,
+	0x11181,
+	0x111181,
+	0x211181,
+	0x11082,
+	0x111082,
+	0x211082,
+	0x11182,
+	0x111182,
+	0x211182,
+	0x11083,
+	0x111083,
+	0x211083,
+	0x11183,
+	0x111183,
+	0x211183,
+	0x12080,
+	0x112080,
+	0x212080,
+	0x12180,
+	0x112180,
+	0x212180,
+	0x12081,
+	0x112081,
+	0x212081,
+	0x12181,
+	0x112181,
+	0x212181,
+	0x12082,
+	0x112082,
+	0x212082,
+	0x12182,
+	0x112182,
+	0x212182,
+	0x12083,
+	0x112083,
+	0x212083,
+	0x12183,
+	0x112183,
+	0x212183,
+	0x13080,
+	0x113080,
+	0x213080,
+	0x13180,
+	0x113180,
+	0x213180,
+	0x13081,
+	0x113081,
+	0x213081,
+	0x13181,
+	0x113181,
+	0x213181,
+	0x13082,
+	0x113082,
+	0x213082,
+	0x13182,
+	0x113182,
+	0x213182,
+	0x13083,
+	0x113083,
+	0x213083,
+	0x13183,
+	0x113183,
+	0x213183,
+	0x100d0,
+	0x1100d0,
+	0x2100d0,
+	0x101d0,
+	0x1101d0,
+	0x2101d0,
+	0x100d1,
+	0x1100d1,
+	0x2100d1,
+	0x101d1,
+	0x1101d1,
+	0x2101d1,
+	0x100d2,
+	0x1100d2,
+	0x2100d2,
+	0x101d2,
+	0x1101d2,
+	0x2101d2,
+	0x100d3,
+	0x1100d3,
+	0x2100d3,
+	0x101d3,
+	0x1101d3,
+	0x2101d3,
+	0x110d0,
+	0x1110d0,
+	0x2110d0,
+	0x111d0,
+	0x1111d0,
+	0x2111d0,
+	0x110d1,
+	0x1110d1,
+	0x2110d1,
+	0x111d1,
+	0x1111d1,
+	0x2111d1,
+	0x110d2,
+	0x1110d2,
+	0x2110d2,
+	0x111d2,
+	0x1111d2,
+	0x2111d2,
+	0x110d3,
+	0x1110d3,
+	0x2110d3,
+	0x111d3,
+	0x1111d3,
+	0x2111d3,
+	0x120d0,
+	0x1120d0,
+	0x2120d0,
+	0x121d0,
+	0x1121d0,
+	0x2121d0,
+	0x120d1,
+	0x1120d1,
+	0x2120d1,
+	0x121d1,
+	0x1121d1,
+	0x2121d1,
+	0x120d2,
+	0x1120d2,
+	0x2120d2,
+	0x121d2,
+	0x1121d2,
+	0x2121d2,
+	0x120d3,
+	0x1120d3,
+	0x2120d3,
+	0x121d3,
+	0x1121d3,
+	0x2121d3,
+	0x130d0,
+	0x1130d0,
+	0x2130d0,
+	0x131d0,
+	0x1131d0,
+	0x2131d0,
+	0x130d1,
+	0x1130d1,
+	0x2130d1,
+	0x131d1,
+	0x1131d1,
+	0x2131d1,
+	0x130d2,
+	0x1130d2,
+	0x2130d2,
+	0x131d2,
+	0x1131d2,
+	0x2131d2,
+	0x130d3,
+	0x1130d3,
+	0x2130d3,
+	0x131d3,
+	0x1131d3,
+	0x2131d3,
+	0x10068,
+	0x10168,
+	0x10268,
+	0x10368,
+	0x10468,
+	0x10568,
+	0x10668,
+	0x10768,
+	0x10868,
+	0x10069,
+	0x10169,
+	0x10269,
+	0x10369,
+	0x10469,
+	0x10569,
+	0x10669,
+	0x10769,
+	0x10869,
+	0x1006a,
+	0x1016a,
+	0x1026a,
+	0x1036a,
+	0x1046a,
+	0x1056a,
+	0x1066a,
+	0x1076a,
+	0x1086a,
+	0x1006b,
+	0x1016b,
+	0x1026b,
+	0x1036b,
+	0x1046b,
+	0x1056b,
+	0x1066b,
+	0x1076b,
+	0x1086b,
+	0x11068,
+	0x11168,
+	0x11268,
+	0x11368,
+	0x11468,
+	0x11568,
+	0x11668,
+	0x11768,
+	0x11868,
+	0x11069,
+	0x11169,
+	0x11269,
+	0x11369,
+	0x11469,
+	0x11569,
+	0x11669,
+	0x11769,
+	0x11869,
+	0x1106a,
+	0x1116a,
+	0x1126a,
+	0x1136a,
+	0x1146a,
+	0x1156a,
+	0x1166a,
+	0x1176a,
+	0x1186a,
+	0x1106b,
+	0x1116b,
+	0x1126b,
+	0x1136b,
+	0x1146b,
+	0x1156b,
+	0x1166b,
+	0x1176b,
+	0x1186b,
+	0x12068,
+	0x12168,
+	0x12268,
+	0x12368,
+	0x12468,
+	0x12568,
+	0x12668,
+	0x12768,
+	0x12868,
+	0x12069,
+	0x12169,
+	0x12269,
+	0x12369,
+	0x12469,
+	0x12569,
+	0x12669,
+	0x12769,
+	0x12869,
+	0x1206a,
+	0x1216a,
+	0x1226a,
+	0x1236a,
+	0x1246a,
+	0x1256a,
+	0x1266a,
+	0x1276a,
+	0x1286a,
+	0x1206b,
+	0x1216b,
+	0x1226b,
+	0x1236b,
+	0x1246b,
+	0x1256b,
+	0x1266b,
+	0x1276b,
+	0x1286b,
+	0x13068,
+	0x13168,
+	0x13268,
+	0x13368,
+	0x13468,
+	0x13568,
+	0x13668,
+	0x13768,
+	0x13868,
+	0x13069,
+	0x13169,
+	0x13269,
+	0x13369,
+	0x13469,
+	0x13569,
+	0x13669,
+	0x13769,
+	0x13869,
+	0x1306a,
+	0x1316a,
+	0x1326a,
+	0x1336a,
+	0x1346a,
+	0x1356a,
+	0x1366a,
+	0x1376a,
+	0x1386a,
+	0x1306b,
+	0x1316b,
+	0x1326b,
+	0x1336b,
+	0x1346b,
+	0x1356b,
+	0x1366b,
+	0x1376b,
+	0x1386b,
+	0x1008c,
+	0x11008c,
+	0x21008c,
+	0x1018c,
+	0x11018c,
+	0x21018c,
+	0x1008d,
+	0x11008d,
+	0x21008d,
+	0x1018d,
+	0x11018d,
+	0x21018d,
+	0x1008e,
+	0x11008e,
+	0x21008e,
+	0x1018e,
+	0x11018e,
+	0x21018e,
+	0x1008f,
+	0x11008f,
+	0x21008f,
+	0x1018f,
+	0x11018f,
+	0x21018f,
+	0x1108c,
+	0x11108c,
+	0x21108c,
+	0x1118c,
+	0x11118c,
+	0x21118c,
+	0x1108d,
+	0x11108d,
+	0x21108d,
+	0x1118d,
+	0x11118d,
+	0x21118d,
+	0x1108e,
+	0x11108e,
+	0x21108e,
+	0x1118e,
+	0x11118e,
+	0x21118e,
+	0x1108f,
+	0x11108f,
+	0x21108f,
+	0x1118f,
+	0x11118f,
+	0x21118f,
+	0x1208c,
+	0x11208c,
+	0x21208c,
+	0x1218c,
+	0x11218c,
+	0x21218c,
+	0x1208d,
+	0x11208d,
+	0x21208d,
+	0x1218d,
+	0x11218d,
+	0x21218d,
+	0x1208e,
+	0x11208e,
+	0x21208e,
+	0x1218e,
+	0x11218e,
+	0x21218e,
+	0x1208f,
+	0x11208f,
+	0x21208f,
+	0x1218f,
+	0x11218f,
+	0x21218f,
+	0x1308c,
+	0x11308c,
+	0x21308c,
+	0x1318c,
+	0x11318c,
+	0x21318c,
+	0x1308d,
+	0x11308d,
+	0x21308d,
+	0x1318d,
+	0x11318d,
+	0x21318d,
+	0x1308e,
+	0x11308e,
+	0x21308e,
+	0x1318e,
+	0x11318e,
+	0x21318e,
+	0x1308f,
+	0x11308f,
+	0x21308f,
+	0x1318f,
+	0x11318f,
+	0x21318f,
+	0x100c0,
+	0x1100c0,
+	0x2100c0,
+	0x101c0,
+	0x1101c0,
+	0x2101c0,
+	0x102c0,
+	0x1102c0,
+	0x2102c0,
+	0x103c0,
+	0x1103c0,
+	0x2103c0,
+	0x104c0,
+	0x1104c0,
+	0x2104c0,
+	0x105c0,
+	0x1105c0,
+	0x2105c0,
+	0x106c0,
+	0x1106c0,
+	0x2106c0,
+	0x107c0,
+	0x1107c0,
+	0x2107c0,
+	0x108c0,
+	0x1108c0,
+	0x2108c0,
+	0x100c1,
+	0x1100c1,
+	0x2100c1,
+	0x101c1,
+	0x1101c1,
+	0x2101c1,
+	0x102c1,
+	0x1102c1,
+	0x2102c1,
+	0x103c1,
+	0x1103c1,
+	0x2103c1,
+	0x104c1,
+	0x1104c1,
+	0x2104c1,
+	0x105c1,
+	0x1105c1,
+	0x2105c1,
+	0x106c1,
+	0x1106c1,
+	0x2106c1,
+	0x107c1,
+	0x1107c1,
+	0x2107c1,
+	0x108c1,
+	0x1108c1,
+	0x2108c1,
+	0x100c2,
+	0x1100c2,
+	0x2100c2,
+	0x101c2,
+	0x1101c2,
+	0x2101c2,
+	0x102c2,
+	0x1102c2,
+	0x2102c2,
+	0x103c2,
+	0x1103c2,
+	0x2103c2,
+	0x104c2,
+	0x1104c2,
+	0x2104c2,
+	0x105c2,
+	0x1105c2,
+	0x2105c2,
+	0x106c2,
+	0x1106c2,
+	0x2106c2,
+	0x107c2,
+	0x1107c2,
+	0x2107c2,
+	0x108c2,
+	0x1108c2,
+	0x2108c2,
+	0x100c3,
+	0x1100c3,
+	0x2100c3,
+	0x101c3,
+	0x1101c3,
+	0x2101c3,
+	0x102c3,
+	0x1102c3,
+	0x2102c3,
+	0x103c3,
+	0x1103c3,
+	0x2103c3,
+	0x104c3,
+	0x1104c3,
+	0x2104c3,
+	0x105c3,
+	0x1105c3,
+	0x2105c3,
+	0x106c3,
+	0x1106c3,
+	0x2106c3,
+	0x107c3,
+	0x1107c3,
+	0x2107c3,
+	0x108c3,
+	0x1108c3,
+	0x2108c3,
+	0x110c0,
+	0x1110c0,
+	0x2110c0,
+	0x111c0,
+	0x1111c0,
+	0x2111c0,
+	0x112c0,
+	0x1112c0,
+	0x2112c0,
+	0x113c0,
+	0x1113c0,
+	0x2113c0,
+	0x114c0,
+	0x1114c0,
+	0x2114c0,
+	0x115c0,
+	0x1115c0,
+	0x2115c0,
+	0x116c0,
+	0x1116c0,
+	0x2116c0,
+	0x117c0,
+	0x1117c0,
+	0x2117c0,
+	0x118c0,
+	0x1118c0,
+	0x2118c0,
+	0x110c1,
+	0x1110c1,
+	0x2110c1,
+	0x111c1,
+	0x1111c1,
+	0x2111c1,
+	0x112c1,
+	0x1112c1,
+	0x2112c1,
+	0x113c1,
+	0x1113c1,
+	0x2113c1,
+	0x114c1,
+	0x1114c1,
+	0x2114c1,
+	0x115c1,
+	0x1115c1,
+	0x2115c1,
+	0x116c1,
+	0x1116c1,
+	0x2116c1,
+	0x117c1,
+	0x1117c1,
+	0x2117c1,
+	0x118c1,
+	0x1118c1,
+	0x2118c1,
+	0x110c2,
+	0x1110c2,
+	0x2110c2,
+	0x111c2,
+	0x1111c2,
+	0x2111c2,
+	0x112c2,
+	0x1112c2,
+	0x2112c2,
+	0x113c2,
+	0x1113c2,
+	0x2113c2,
+	0x114c2,
+	0x1114c2,
+	0x2114c2,
+	0x115c2,
+	0x1115c2,
+	0x2115c2,
+	0x116c2,
+	0x1116c2,
+	0x2116c2,
+	0x117c2,
+	0x1117c2,
+	0x2117c2,
+	0x118c2,
+	0x1118c2,
+	0x2118c2,
+	0x110c3,
+	0x1110c3,
+	0x2110c3,
+	0x111c3,
+	0x1111c3,
+	0x2111c3,
+	0x112c3,
+	0x1112c3,
+	0x2112c3,
+	0x113c3,
+	0x1113c3,
+	0x2113c3,
+	0x114c3,
+	0x1114c3,
+	0x2114c3,
+	0x115c3,
+	0x1115c3,
+	0x2115c3,
+	0x116c3,
+	0x1116c3,
+	0x2116c3,
+	0x117c3,
+	0x1117c3,
+	0x2117c3,
+	0x118c3,
+	0x1118c3,
+	0x2118c3,
+	0x120c0,
+	0x1120c0,
+	0x2120c0,
+	0x121c0,
+	0x1121c0,
+	0x2121c0,
+	0x122c0,
+	0x1122c0,
+	0x2122c0,
+	0x123c0,
+	0x1123c0,
+	0x2123c0,
+	0x124c0,
+	0x1124c0,
+	0x2124c0,
+	0x125c0,
+	0x1125c0,
+	0x2125c0,
+	0x126c0,
+	0x1126c0,
+	0x2126c0,
+	0x127c0,
+	0x1127c0,
+	0x2127c0,
+	0x128c0,
+	0x1128c0,
+	0x2128c0,
+	0x120c1,
+	0x1120c1,
+	0x2120c1,
+	0x121c1,
+	0x1121c1,
+	0x2121c1,
+	0x122c1,
+	0x1122c1,
+	0x2122c1,
+	0x123c1,
+	0x1123c1,
+	0x2123c1,
+	0x124c1,
+	0x1124c1,
+	0x2124c1,
+	0x125c1,
+	0x1125c1,
+	0x2125c1,
+	0x126c1,
+	0x1126c1,
+	0x2126c1,
+	0x127c1,
+	0x1127c1,
+	0x2127c1,
+	0x128c1,
+	0x1128c1,
+	0x2128c1,
+	0x120c2,
+	0x1120c2,
+	0x2120c2,
+	0x121c2,
+	0x1121c2,
+	0x2121c2,
+	0x122c2,
+	0x1122c2,
+	0x2122c2,
+	0x123c2,
+	0x1123c2,
+	0x2123c2,
+	0x124c2,
+	0x1124c2,
+	0x2124c2,
+	0x125c2,
+	0x1125c2,
+	0x2125c2,
+	0x126c2,
+	0x1126c2,
+	0x2126c2,
+	0x127c2,
+	0x1127c2,
+	0x2127c2,
+	0x128c2,
+	0x1128c2,
+	0x2128c2,
+	0x120c3,
+	0x1120c3,
+	0x2120c3,
+	0x121c3,
+	0x1121c3,
+	0x2121c3,
+	0x122c3,
+	0x1122c3,
+	0x2122c3,
+	0x123c3,
+	0x1123c3,
+	0x2123c3,
+	0x124c3,
+	0x1124c3,
+	0x2124c3,
+	0x125c3,
+	0x1125c3,
+	0x2125c3,
+	0x126c3,
+	0x1126c3,
+	0x2126c3,
+	0x127c3,
+	0x1127c3,
+	0x2127c3,
+	0x128c3,
+	0x1128c3,
+	0x2128c3,
+	0x130c0,
+	0x1130c0,
+	0x2130c0,
+	0x131c0,
+	0x1131c0,
+	0x2131c0,
+	0x132c0,
+	0x1132c0,
+	0x2132c0,
+	0x133c0,
+	0x1133c0,
+	0x2133c0,
+	0x134c0,
+	0x1134c0,
+	0x2134c0,
+	0x135c0,
+	0x1135c0,
+	0x2135c0,
+	0x136c0,
+	0x1136c0,
+	0x2136c0,
+	0x137c0,
+	0x1137c0,
+	0x2137c0,
+	0x138c0,
+	0x1138c0,
+	0x2138c0,
+	0x130c1,
+	0x1130c1,
+	0x2130c1,
+	0x131c1,
+	0x1131c1,
+	0x2131c1,
+	0x132c1,
+	0x1132c1,
+	0x2132c1,
+	0x133c1,
+	0x1133c1,
+	0x2133c1,
+	0x134c1,
+	0x1134c1,
+	0x2134c1,
+	0x135c1,
+	0x1135c1,
+	0x2135c1,
+	0x136c1,
+	0x1136c1,
+	0x2136c1,
+	0x137c1,
+	0x1137c1,
+	0x2137c1,
+	0x138c1,
+	0x1138c1,
+	0x2138c1,
+	0x130c2,
+	0x1130c2,
+	0x2130c2,
+	0x131c2,
+	0x1131c2,
+	0x2131c2,
+	0x132c2,
+	0x1132c2,
+	0x2132c2,
+	0x133c2,
+	0x1133c2,
+	0x2133c2,
+	0x134c2,
+	0x1134c2,
+	0x2134c2,
+	0x135c2,
+	0x1135c2,
+	0x2135c2,
+	0x136c2,
+	0x1136c2,
+	0x2136c2,
+	0x137c2,
+	0x1137c2,
+	0x2137c2,
+	0x138c2,
+	0x1138c2,
+	0x2138c2,
+	0x130c3,
+	0x1130c3,
+	0x2130c3,
+	0x131c3,
+	0x1131c3,
+	0x2131c3,
+	0x132c3,
+	0x1132c3,
+	0x2132c3,
+	0x133c3,
+	0x1133c3,
+	0x2133c3,
+	0x134c3,
+	0x1134c3,
+	0x2134c3,
+	0x135c3,
+	0x1135c3,
+	0x2135c3,
+	0x136c3,
+	0x1136c3,
+	0x2136c3,
+	0x137c3,
+	0x1137c3,
+	0x2137c3,
+	0x138c3,
+	0x1138c3,
+	0x2138c3,
+	0x10020,
+	0x110020,
+	0x210020,
+	0x11020,
+	0x111020,
+	0x211020,
+	0x12020,
+	0x112020,
+	0x212020,
+	0x13020,
+	0x113020,
+#endif
+	0x213020,
+	0x2007d,
+	0x12007d,
+	0x22007d,
+	0
+};
+
+void restore_1d2d_trained_csr_ddr3_p012(unsigned int addr)
+{
+	unsigned int i;
+
+	dwc_ddrphy_apb_wr(0xd0000, 0x0); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	for (i = 0; restore_csr[i] != 0; i++) {
+		dwc_ddrphy_apb_wr(restore_csr[i], reg32_read(addr + (i << 2)));
+	}
+	dwc_ddrphy_apb_wr(0xd0000, 0x1); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+
+	ddr_dbg("restore 1d2d training registers done \n");
+}
diff --git a/board/karo/tx8mm/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c b/board/karo/tx8mm/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
new file mode 100644
index 0000000000000000000000000000000000000000..4ea62bbc2bdb387911115b311aa7e9ff2a549c60
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr3l/save_1d2d_trained_csr_ddr3_p012.c
@@ -0,0 +1,971 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "../ddr.h"
+#include "ddr3_define.h"
+
+static const unsigned int save_csr[] = {
+	0x200b2,
+	0x1200b2,
+	0x2200b2,
+	0x200cb,
+#ifdef RUN_ON_SILICON
+	0x10043,
+	0x110043,
+	0x210043,
+	0x10143,
+	0x110143,
+	0x210143,
+	0x11043,
+	0x111043,
+	0x211043,
+	0x11143,
+	0x111143,
+	0x211143,
+	0x12043,
+	0x112043,
+	0x212043,
+	0x12143,
+	0x112143,
+	0x212143,
+	0x13043,
+	0x113043,
+	0x213043,
+	0x13143,
+	0x113143,
+	0x213143,
+	0x80,
+	0x100080,
+	0x200080,
+	0x1080,
+	0x101080,
+	0x201080,
+	0x2080,
+	0x102080,
+	0x202080,
+	0x3080,
+	0x103080,
+	0x203080,
+	0x4080,
+	0x104080,
+	0x204080,
+	0x5080,
+	0x105080,
+	0x205080,
+	0x6080,
+	0x106080,
+	0x206080,
+	0x7080,
+	0x107080,
+	0x207080,
+	0x8080,
+	0x108080,
+	0x208080,
+	0x9080,
+	0x109080,
+	0x209080,
+	0x10080,
+	0x110080,
+	0x210080,
+	0x10180,
+	0x110180,
+	0x210180,
+	0x10081,
+	0x110081,
+	0x210081,
+	0x10181,
+	0x110181,
+	0x210181,
+	0x10082,
+	0x110082,
+	0x210082,
+	0x10182,
+	0x110182,
+	0x210182,
+	0x10083,
+	0x110083,
+	0x210083,
+	0x10183,
+	0x110183,
+	0x210183,
+	0x11080,
+	0x111080,
+	0x211080,
+	0x11180,
+	0x111180,
+	0x211180,
+	0x11081,
+	0x111081,
+	0x211081,
+	0x11181,
+	0x111181,
+	0x211181,
+	0x11082,
+	0x111082,
+	0x211082,
+	0x11182,
+	0x111182,
+	0x211182,
+	0x11083,
+	0x111083,
+	0x211083,
+	0x11183,
+	0x111183,
+	0x211183,
+	0x12080,
+	0x112080,
+	0x212080,
+	0x12180,
+	0x112180,
+	0x212180,
+	0x12081,
+	0x112081,
+	0x212081,
+	0x12181,
+	0x112181,
+	0x212181,
+	0x12082,
+	0x112082,
+	0x212082,
+	0x12182,
+	0x112182,
+	0x212182,
+	0x12083,
+	0x112083,
+	0x212083,
+	0x12183,
+	0x112183,
+	0x212183,
+	0x13080,
+	0x113080,
+	0x213080,
+	0x13180,
+	0x113180,
+	0x213180,
+	0x13081,
+	0x113081,
+	0x213081,
+	0x13181,
+	0x113181,
+	0x213181,
+	0x13082,
+	0x113082,
+	0x213082,
+	0x13182,
+	0x113182,
+	0x213182,
+	0x13083,
+	0x113083,
+	0x213083,
+	0x13183,
+	0x113183,
+	0x213183,
+	0x100d0,
+	0x1100d0,
+	0x2100d0,
+	0x101d0,
+	0x1101d0,
+	0x2101d0,
+	0x100d1,
+	0x1100d1,
+	0x2100d1,
+	0x101d1,
+	0x1101d1,
+	0x2101d1,
+	0x100d2,
+	0x1100d2,
+	0x2100d2,
+	0x101d2,
+	0x1101d2,
+	0x2101d2,
+	0x100d3,
+	0x1100d3,
+	0x2100d3,
+	0x101d3,
+	0x1101d3,
+	0x2101d3,
+	0x110d0,
+	0x1110d0,
+	0x2110d0,
+	0x111d0,
+	0x1111d0,
+	0x2111d0,
+	0x110d1,
+	0x1110d1,
+	0x2110d1,
+	0x111d1,
+	0x1111d1,
+	0x2111d1,
+	0x110d2,
+	0x1110d2,
+	0x2110d2,
+	0x111d2,
+	0x1111d2,
+	0x2111d2,
+	0x110d3,
+	0x1110d3,
+	0x2110d3,
+	0x111d3,
+	0x1111d3,
+	0x2111d3,
+	0x120d0,
+	0x1120d0,
+	0x2120d0,
+	0x121d0,
+	0x1121d0,
+	0x2121d0,
+	0x120d1,
+	0x1120d1,
+	0x2120d1,
+	0x121d1,
+	0x1121d1,
+	0x2121d1,
+	0x120d2,
+	0x1120d2,
+	0x2120d2,
+	0x121d2,
+	0x1121d2,
+	0x2121d2,
+	0x120d3,
+	0x1120d3,
+	0x2120d3,
+	0x121d3,
+	0x1121d3,
+	0x2121d3,
+	0x130d0,
+	0x1130d0,
+	0x2130d0,
+	0x131d0,
+	0x1131d0,
+	0x2131d0,
+	0x130d1,
+	0x1130d1,
+	0x2130d1,
+	0x131d1,
+	0x1131d1,
+	0x2131d1,
+	0x130d2,
+	0x1130d2,
+	0x2130d2,
+	0x131d2,
+	0x1131d2,
+	0x2131d2,
+	0x130d3,
+	0x1130d3,
+	0x2130d3,
+	0x131d3,
+	0x1131d3,
+	0x2131d3,
+	0x10068,
+	0x10168,
+	0x10268,
+	0x10368,
+	0x10468,
+	0x10568,
+	0x10668,
+	0x10768,
+	0x10868,
+	0x10069,
+	0x10169,
+	0x10269,
+	0x10369,
+	0x10469,
+	0x10569,
+	0x10669,
+	0x10769,
+	0x10869,
+	0x1006a,
+	0x1016a,
+	0x1026a,
+	0x1036a,
+	0x1046a,
+	0x1056a,
+	0x1066a,
+	0x1076a,
+	0x1086a,
+	0x1006b,
+	0x1016b,
+	0x1026b,
+	0x1036b,
+	0x1046b,
+	0x1056b,
+	0x1066b,
+	0x1076b,
+	0x1086b,
+	0x11068,
+	0x11168,
+	0x11268,
+	0x11368,
+	0x11468,
+	0x11568,
+	0x11668,
+	0x11768,
+	0x11868,
+	0x11069,
+	0x11169,
+	0x11269,
+	0x11369,
+	0x11469,
+	0x11569,
+	0x11669,
+	0x11769,
+	0x11869,
+	0x1106a,
+	0x1116a,
+	0x1126a,
+	0x1136a,
+	0x1146a,
+	0x1156a,
+	0x1166a,
+	0x1176a,
+	0x1186a,
+	0x1106b,
+	0x1116b,
+	0x1126b,
+	0x1136b,
+	0x1146b,
+	0x1156b,
+	0x1166b,
+	0x1176b,
+	0x1186b,
+	0x12068,
+	0x12168,
+	0x12268,
+	0x12368,
+	0x12468,
+	0x12568,
+	0x12668,
+	0x12768,
+	0x12868,
+	0x12069,
+	0x12169,
+	0x12269,
+	0x12369,
+	0x12469,
+	0x12569,
+	0x12669,
+	0x12769,
+	0x12869,
+	0x1206a,
+	0x1216a,
+	0x1226a,
+	0x1236a,
+	0x1246a,
+	0x1256a,
+	0x1266a,
+	0x1276a,
+	0x1286a,
+	0x1206b,
+	0x1216b,
+	0x1226b,
+	0x1236b,
+	0x1246b,
+	0x1256b,
+	0x1266b,
+	0x1276b,
+	0x1286b,
+	0x13068,
+	0x13168,
+	0x13268,
+	0x13368,
+	0x13468,
+	0x13568,
+	0x13668,
+	0x13768,
+	0x13868,
+	0x13069,
+	0x13169,
+	0x13269,
+	0x13369,
+	0x13469,
+	0x13569,
+	0x13669,
+	0x13769,
+	0x13869,
+	0x1306a,
+	0x1316a,
+	0x1326a,
+	0x1336a,
+	0x1346a,
+	0x1356a,
+	0x1366a,
+	0x1376a,
+	0x1386a,
+	0x1306b,
+	0x1316b,
+	0x1326b,
+	0x1336b,
+	0x1346b,
+	0x1356b,
+	0x1366b,
+	0x1376b,
+	0x1386b,
+	0x1008c,
+	0x11008c,
+	0x21008c,
+	0x1018c,
+	0x11018c,
+	0x21018c,
+	0x1008d,
+	0x11008d,
+	0x21008d,
+	0x1018d,
+	0x11018d,
+	0x21018d,
+	0x1008e,
+	0x11008e,
+	0x21008e,
+	0x1018e,
+	0x11018e,
+	0x21018e,
+	0x1008f,
+	0x11008f,
+	0x21008f,
+	0x1018f,
+	0x11018f,
+	0x21018f,
+	0x1108c,
+	0x11108c,
+	0x21108c,
+	0x1118c,
+	0x11118c,
+	0x21118c,
+	0x1108d,
+	0x11108d,
+	0x21108d,
+	0x1118d,
+	0x11118d,
+	0x21118d,
+	0x1108e,
+	0x11108e,
+	0x21108e,
+	0x1118e,
+	0x11118e,
+	0x21118e,
+	0x1108f,
+	0x11108f,
+	0x21108f,
+	0x1118f,
+	0x11118f,
+	0x21118f,
+	0x1208c,
+	0x11208c,
+	0x21208c,
+	0x1218c,
+	0x11218c,
+	0x21218c,
+	0x1208d,
+	0x11208d,
+	0x21208d,
+	0x1218d,
+	0x11218d,
+	0x21218d,
+	0x1208e,
+	0x11208e,
+	0x21208e,
+	0x1218e,
+	0x11218e,
+	0x21218e,
+	0x1208f,
+	0x11208f,
+	0x21208f,
+	0x1218f,
+	0x11218f,
+	0x21218f,
+	0x1308c,
+	0x11308c,
+	0x21308c,
+	0x1318c,
+	0x11318c,
+	0x21318c,
+	0x1308d,
+	0x11308d,
+	0x21308d,
+	0x1318d,
+	0x11318d,
+	0x21318d,
+	0x1308e,
+	0x11308e,
+	0x21308e,
+	0x1318e,
+	0x11318e,
+	0x21318e,
+	0x1308f,
+	0x11308f,
+	0x21308f,
+	0x1318f,
+	0x11318f,
+	0x21318f,
+	0x100c0,
+	0x1100c0,
+	0x2100c0,
+	0x101c0,
+	0x1101c0,
+	0x2101c0,
+	0x102c0,
+	0x1102c0,
+	0x2102c0,
+	0x103c0,
+	0x1103c0,
+	0x2103c0,
+	0x104c0,
+	0x1104c0,
+	0x2104c0,
+	0x105c0,
+	0x1105c0,
+	0x2105c0,
+	0x106c0,
+	0x1106c0,
+	0x2106c0,
+	0x107c0,
+	0x1107c0,
+	0x2107c0,
+	0x108c0,
+	0x1108c0,
+	0x2108c0,
+	0x100c1,
+	0x1100c1,
+	0x2100c1,
+	0x101c1,
+	0x1101c1,
+	0x2101c1,
+	0x102c1,
+	0x1102c1,
+	0x2102c1,
+	0x103c1,
+	0x1103c1,
+	0x2103c1,
+	0x104c1,
+	0x1104c1,
+	0x2104c1,
+	0x105c1,
+	0x1105c1,
+	0x2105c1,
+	0x106c1,
+	0x1106c1,
+	0x2106c1,
+	0x107c1,
+	0x1107c1,
+	0x2107c1,
+	0x108c1,
+	0x1108c1,
+	0x2108c1,
+	0x100c2,
+	0x1100c2,
+	0x2100c2,
+	0x101c2,
+	0x1101c2,
+	0x2101c2,
+	0x102c2,
+	0x1102c2,
+	0x2102c2,
+	0x103c2,
+	0x1103c2,
+	0x2103c2,
+	0x104c2,
+	0x1104c2,
+	0x2104c2,
+	0x105c2,
+	0x1105c2,
+	0x2105c2,
+	0x106c2,
+	0x1106c2,
+	0x2106c2,
+	0x107c2,
+	0x1107c2,
+	0x2107c2,
+	0x108c2,
+	0x1108c2,
+	0x2108c2,
+	0x100c3,
+	0x1100c3,
+	0x2100c3,
+	0x101c3,
+	0x1101c3,
+	0x2101c3,
+	0x102c3,
+	0x1102c3,
+	0x2102c3,
+	0x103c3,
+	0x1103c3,
+	0x2103c3,
+	0x104c3,
+	0x1104c3,
+	0x2104c3,
+	0x105c3,
+	0x1105c3,
+	0x2105c3,
+	0x106c3,
+	0x1106c3,
+	0x2106c3,
+	0x107c3,
+	0x1107c3,
+	0x2107c3,
+	0x108c3,
+	0x1108c3,
+	0x2108c3,
+	0x110c0,
+	0x1110c0,
+	0x2110c0,
+	0x111c0,
+	0x1111c0,
+	0x2111c0,
+	0x112c0,
+	0x1112c0,
+	0x2112c0,
+	0x113c0,
+	0x1113c0,
+	0x2113c0,
+	0x114c0,
+	0x1114c0,
+	0x2114c0,
+	0x115c0,
+	0x1115c0,
+	0x2115c0,
+	0x116c0,
+	0x1116c0,
+	0x2116c0,
+	0x117c0,
+	0x1117c0,
+	0x2117c0,
+	0x118c0,
+	0x1118c0,
+	0x2118c0,
+	0x110c1,
+	0x1110c1,
+	0x2110c1,
+	0x111c1,
+	0x1111c1,
+	0x2111c1,
+	0x112c1,
+	0x1112c1,
+	0x2112c1,
+	0x113c1,
+	0x1113c1,
+	0x2113c1,
+	0x114c1,
+	0x1114c1,
+	0x2114c1,
+	0x115c1,
+	0x1115c1,
+	0x2115c1,
+	0x116c1,
+	0x1116c1,
+	0x2116c1,
+	0x117c1,
+	0x1117c1,
+	0x2117c1,
+	0x118c1,
+	0x1118c1,
+	0x2118c1,
+	0x110c2,
+	0x1110c2,
+	0x2110c2,
+	0x111c2,
+	0x1111c2,
+	0x2111c2,
+	0x112c2,
+	0x1112c2,
+	0x2112c2,
+	0x113c2,
+	0x1113c2,
+	0x2113c2,
+	0x114c2,
+	0x1114c2,
+	0x2114c2,
+	0x115c2,
+	0x1115c2,
+	0x2115c2,
+	0x116c2,
+	0x1116c2,
+	0x2116c2,
+	0x117c2,
+	0x1117c2,
+	0x2117c2,
+	0x118c2,
+	0x1118c2,
+	0x2118c2,
+	0x110c3,
+	0x1110c3,
+	0x2110c3,
+	0x111c3,
+	0x1111c3,
+	0x2111c3,
+	0x112c3,
+	0x1112c3,
+	0x2112c3,
+	0x113c3,
+	0x1113c3,
+	0x2113c3,
+	0x114c3,
+	0x1114c3,
+	0x2114c3,
+	0x115c3,
+	0x1115c3,
+	0x2115c3,
+	0x116c3,
+	0x1116c3,
+	0x2116c3,
+	0x117c3,
+	0x1117c3,
+	0x2117c3,
+	0x118c3,
+	0x1118c3,
+	0x2118c3,
+	0x120c0,
+	0x1120c0,
+	0x2120c0,
+	0x121c0,
+	0x1121c0,
+	0x2121c0,
+	0x122c0,
+	0x1122c0,
+	0x2122c0,
+	0x123c0,
+	0x1123c0,
+	0x2123c0,
+	0x124c0,
+	0x1124c0,
+	0x2124c0,
+	0x125c0,
+	0x1125c0,
+	0x2125c0,
+	0x126c0,
+	0x1126c0,
+	0x2126c0,
+	0x127c0,
+	0x1127c0,
+	0x2127c0,
+	0x128c0,
+	0x1128c0,
+	0x2128c0,
+	0x120c1,
+	0x1120c1,
+	0x2120c1,
+	0x121c1,
+	0x1121c1,
+	0x2121c1,
+	0x122c1,
+	0x1122c1,
+	0x2122c1,
+	0x123c1,
+	0x1123c1,
+	0x2123c1,
+	0x124c1,
+	0x1124c1,
+	0x2124c1,
+	0x125c1,
+	0x1125c1,
+	0x2125c1,
+	0x126c1,
+	0x1126c1,
+	0x2126c1,
+	0x127c1,
+	0x1127c1,
+	0x2127c1,
+	0x128c1,
+	0x1128c1,
+	0x2128c1,
+	0x120c2,
+	0x1120c2,
+	0x2120c2,
+	0x121c2,
+	0x1121c2,
+	0x2121c2,
+	0x122c2,
+	0x1122c2,
+	0x2122c2,
+	0x123c2,
+	0x1123c2,
+	0x2123c2,
+	0x124c2,
+	0x1124c2,
+	0x2124c2,
+	0x125c2,
+	0x1125c2,
+	0x2125c2,
+	0x126c2,
+	0x1126c2,
+	0x2126c2,
+	0x127c2,
+	0x1127c2,
+	0x2127c2,
+	0x128c2,
+	0x1128c2,
+	0x2128c2,
+	0x120c3,
+	0x1120c3,
+	0x2120c3,
+	0x121c3,
+	0x1121c3,
+	0x2121c3,
+	0x122c3,
+	0x1122c3,
+	0x2122c3,
+	0x123c3,
+	0x1123c3,
+	0x2123c3,
+	0x124c3,
+	0x1124c3,
+	0x2124c3,
+	0x125c3,
+	0x1125c3,
+	0x2125c3,
+	0x126c3,
+	0x1126c3,
+	0x2126c3,
+	0x127c3,
+	0x1127c3,
+	0x2127c3,
+	0x128c3,
+	0x1128c3,
+	0x2128c3,
+	0x130c0,
+	0x1130c0,
+	0x2130c0,
+	0x131c0,
+	0x1131c0,
+	0x2131c0,
+	0x132c0,
+	0x1132c0,
+	0x2132c0,
+	0x133c0,
+	0x1133c0,
+	0x2133c0,
+	0x134c0,
+	0x1134c0,
+	0x2134c0,
+	0x135c0,
+	0x1135c0,
+	0x2135c0,
+	0x136c0,
+	0x1136c0,
+	0x2136c0,
+	0x137c0,
+	0x1137c0,
+	0x2137c0,
+	0x138c0,
+	0x1138c0,
+	0x2138c0,
+	0x130c1,
+	0x1130c1,
+	0x2130c1,
+	0x131c1,
+	0x1131c1,
+	0x2131c1,
+	0x132c1,
+	0x1132c1,
+	0x2132c1,
+	0x133c1,
+	0x1133c1,
+	0x2133c1,
+	0x134c1,
+	0x1134c1,
+	0x2134c1,
+	0x135c1,
+	0x1135c1,
+	0x2135c1,
+	0x136c1,
+	0x1136c1,
+	0x2136c1,
+	0x137c1,
+	0x1137c1,
+	0x2137c1,
+	0x138c1,
+	0x1138c1,
+	0x2138c1,
+	0x130c2,
+	0x1130c2,
+	0x2130c2,
+	0x131c2,
+	0x1131c2,
+	0x2131c2,
+	0x132c2,
+	0x1132c2,
+	0x2132c2,
+	0x133c2,
+	0x1133c2,
+	0x2133c2,
+	0x134c2,
+	0x1134c2,
+	0x2134c2,
+	0x135c2,
+	0x1135c2,
+	0x2135c2,
+	0x136c2,
+	0x1136c2,
+	0x2136c2,
+	0x137c2,
+	0x1137c2,
+	0x2137c2,
+	0x138c2,
+	0x1138c2,
+	0x2138c2,
+	0x130c3,
+	0x1130c3,
+	0x2130c3,
+	0x131c3,
+	0x1131c3,
+	0x2131c3,
+	0x132c3,
+	0x1132c3,
+	0x2132c3,
+	0x133c3,
+	0x1133c3,
+	0x2133c3,
+	0x134c3,
+	0x1134c3,
+	0x2134c3,
+	0x135c3,
+	0x1135c3,
+	0x2135c3,
+	0x136c3,
+	0x1136c3,
+	0x2136c3,
+	0x137c3,
+	0x1137c3,
+	0x2137c3,
+	0x138c3,
+	0x1138c3,
+	0x2138c3,
+	0x10020,
+	0x110020,
+	0x210020,
+	0x11020,
+	0x111020,
+	0x211020,
+	0x12020,
+	0x112020,
+	0x212020,
+	0x13020,
+	0x113020,
+#endif
+	0x213020,
+	0x2007d,
+	0x12007d,
+	0x22007d,
+	0
+};
+
+void save_1d2d_trained_csr_ddr3_p012(unsigned int addr)
+{
+	unsigned int i;
+
+	dwc_ddrphy_apb_wr(0xd0000, 0x0); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+	dwc_ddrphy_apb_wr(0xc0080, 0x3); /* DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
+	for (i = 0; save_csr[i] != 0; i++) {
+		reg32_write(addr + (i << 2), dwc_ddrphy_apb_rd(save_csr[i]));
+	}
+	dwc_ddrphy_apb_wr(0xc0080, 0x0); /* DWC_DDRPHYA_DRTUB0_UcclkHclkEnables */
+	dwc_ddrphy_apb_wr(0xd0000, 0x1); /* DWC_DDRPHYA_APBONLY0_MicroContMuxSel */
+
+	ddr_dbg("save 1d2d training registers done \n");
+}
diff --git a/board/karo/tx8mm/ddr/ddr_init.c b/board/karo/tx8mm/ddr/ddr_init.c
new file mode 100644
index 0000000000000000000000000000000000000000..6d15c114380dbfb389139cc932a136121625660e
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddr_init.c
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Generated code from MX8M_DDR_tool
+ * Align with uboot-imx_v2017.03_4.9.51_imx8m_ga
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "ddr.h"
+
+#ifdef CONFIG_ENABLE_DDR_TRAINING_DEBUG
+#define ddr_printf(args...) printf(args)
+#else
+#define ddr_printf(args...) do {} while (0)
+#endif
+
+#define SILICON_TRAIN
+
+void ddr_cfg_phy(void);
+volatile unsigned int tmp, tmp_t, i;
+void ddr_init(void)
+{
+	/** Initialize DDR clock and DDRC registers **/
+	reg32_write(0x30391000, 0x8f00003f);
+	reg32_write(0x30391000, 0x8f00000f);
+	reg32_write(0x3038a088, 0x7070000);
+	reg32_write(0x3038a084, 0x4030000);
+	reg32_write(0x303a00ec, 0xffff);
+	tmp = reg32_read(0x303a00f8);
+	tmp |= 0x20;
+	reg32_write(0x303a00f8,tmp);
+	reg32_write(0x30391004, 0x8f000000);
+	reg32_write(0x30360054, 0x12c091);
+	reg32_write(0x30360058, 0x0);
+	tmp = reg32_read(0x30360050);
+	tmp |= 0x200;
+	reg32_write(0x30360050,tmp);
+	tmp = reg32_read(0x30360050);
+	tmp &= ~0x10;
+	reg32_write(0x30360050,tmp);
+	do {
+		tmp = reg32_read(0x30360050);
+		if (tmp & 0x80000000)
+			break;
+	} while (1);
+	reg32_write(0x30391000, 0x8f000006);
+	reg32_write(0x3d400304, 0x1);
+	reg32_write(0x3d400030, 0x20);
+	reg32_write(0x3d400000, 0x81040001);
+	reg32_write(0x3d400010, 0x40004010);
+	reg32_write(0x3d400064, 0x610068);
+	reg32_write(0x3d4000d0, 0xc00200c5);
+	reg32_write(0x3d4000d4, 0x1000b);
+	reg32_write(0x3d4000dc, 0x1c700004);
+	reg32_write(0x3d4000e0, 0x180000);
+	reg32_write(0x3d4000e4, 0x90000);
+	reg32_write(0x3d4000f0, 0x0);
+	reg32_write(0x3d4000f4, 0xee5);
+	reg32_write(0x3d400100, 0xc101b0e);
+	reg32_write(0x3d400104, 0x30314);
+	reg32_write(0x3d400108, 0x4060509);
+	reg32_write(0x3d40010c, 0x2006);
+	reg32_write(0x3d400110, 0x6020306);
+	reg32_write(0x3d400114, 0x4040302);
+	reg32_write(0x3d400120, 0x905);
+	reg32_write(0x3d400180, 0x40800020);
+	reg32_write(0x3d400184, 0xc350);
+	reg32_write(0x3d400190, 0x3868203);
+	reg32_write(0x3d400194, 0x20303);
+	reg32_write(0x3d4001b4, 0x603);
+	reg32_write(0x3d400198, 0x7000000);
+	reg32_write(0x3d4001b0, 0x11);
+	reg32_write(0x3d4001a0, 0x400018);
+	reg32_write(0x3d4001a4, 0x5003c);
+	reg32_write(0x3d4001a8, 0x80000000);
+	reg32_write(0x3d4001c4, 0x1);
+	reg32_write(0x3d400200, 0x1f);
+	reg32_write(0x3d400204, 0x80808);
+	reg32_write(0x3d400208, 0x0);
+	reg32_write(0x3d40020c, 0x0);
+	reg32_write(0x3d400210, 0x1f1f);
+	reg32_write(0x3d400214, 0x7070707);
+	reg32_write(0x3d400218, 0xf070707);
+	reg32_write(0x3d400224, 0xa020b06);
+	reg32_write(0x3d400228, 0xa0a0a0a);
+	reg32_write(0x3d40022c, 0x0);
+	reg32_write(0x3d400240, 0x600060c);
+	reg32_write(0x3d400244, 0x1323);
+	reg32_write(0x3d400264, 0x9);
+	reg32_write(0x3d40049c, 0x100001);
+	reg32_write(0x3d4004a0, 0x41f);
+	reg32_write(0x30391000, 0x8f000000);
+	reg32_write(0x3d400304, 0x0);
+	reg32_write(0x3d400030, 0xa8);
+	reg32_write(0x3d400320, 0x0);
+	reg32_write(0x30391000, 0x8f000004);
+	reg32_write(0x30391000, 0x8f000000);
+	reg32_write(0x3d400320, 0x0);
+	reg32_write(0x3d4001b0, 0x0);
+	do {
+		tmp = reg32_read(0x3d400308);
+		if (tmp & 0x36000000) break;
+	} while (1);
+	reg32_write(0x3d400490, 0x0);
+	do {
+		tmp = reg32_read(0x3d4003fc);
+		if ((tmp & 0x10001) == 0) break;
+	} while (1);
+	reg32_write(0x3d400030, 0xa8);
+	do {
+		tmp = reg32_read(0x3d400004);
+		if (tmp & 0x3) break;
+	} while (1);
+
+	/* Configure DDR PHY's registers */
+	ddr_cfg_phy();
+
+	reg32_write(DDRC_RFSHCTL3(0), 0x00000000);
+	reg32_write(DDRC_SWCTL(0), 0x0000);
+	/*
+	 * ------------------- 9 -------------------
+	 * Set DFIMISC.dfi_init_start to 1
+	 *  -----------------------------------------
+	 */
+	reg32_write(DDRC_DFIMISC(0), 0x00000030);
+	reg32_write(DDRC_SWCTL(0), 0x0001);
+
+	/* wait DFISTAT.dfi_init_complete to 1 */
+	tmp_t = 0;
+	while (tmp_t == 0) {
+		tmp  = reg32_read(DDRC_DFISTAT(0));
+		tmp_t = tmp & 0x01;
+		tmp  = reg32_read(DDRC_MRSTAT(0));
+	}
+
+	reg32_write(DDRC_SWCTL(0), 0x0000);
+
+	/* clear DFIMISC.dfi_init_complete_en */
+	reg32_write(DDRC_DFIMISC(0), 0x00000010);
+	reg32_write(DDRC_DFIMISC(0), 0x00000011);
+	reg32_write(DDRC_PWRCTL(0), 0x00000088);
+
+	tmp = reg32_read(DDRC_CRCPARSTAT(0));
+	/*
+	 * set SWCTL.sw_done to enable quasi-dynamic register
+	 * programming outside reset.
+	 */
+	reg32_write(DDRC_SWCTL(0), 0x00000001);
+
+	/* wait SWSTAT.sw_done_ack to 1 */
+	while ((reg32_read(DDRC_SWSTAT(0)) & 0x1) == 0)
+		;
+
+	/* wait STAT.operating_mode([1:0] for ddr3) to normal state */
+	while ((reg32_read(DDRC_STAT(0)) & 0x3) != 0x1)
+		;
+
+	reg32_write(DDRC_PWRCTL(0), 0x00000088);
+	/* reg32_write(DDRC_PWRCTL(0), 0x018a); */
+	tmp = reg32_read(DDRC_CRCPARSTAT(0));
+
+	/* enable port 0 */
+	reg32_write(DDRC_PCTRL_0(0), 0x00000001);
+	/* enable DDR auto-refresh mode */
+	tmp = reg32_read(DDRC_RFSHCTL3(0)) & ~0x1;
+	reg32_write(DDRC_RFSHCTL3(0), tmp);
+}
diff --git a/board/karo/tx8mm/ddr/ddrphy_train.c b/board/karo/tx8mm/ddr/ddrphy_train.c
new file mode 100644
index 0000000000000000000000000000000000000000..3d9fe28925d922473e4d0c4144f8585aaf9071fe
--- /dev/null
+++ b/board/karo/tx8mm/ddr/ddrphy_train.c
@@ -0,0 +1,351 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Generated code from MX8M_DDR_tool
+ * Align with uboot-imx_v2017.03_4.9.51_imx8m_ga
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include "ddr.h"
+
+extern void wait_ddrphy_training_complete(void);
+void ddr_cfg_phy(void) {
+	unsigned int tmp, calbusy;
+
+	//Init DDRPHY register...
+	reg32_write(0x3c04017c, 0x3ff);
+	reg32_write(0x3c04057c, 0x3ff);
+	reg32_write(0x3c04417c, 0x3ff);
+	reg32_write(0x3c04457c, 0x3ff);
+	reg32_write(0x3c04817c, 0x3ff);
+	reg32_write(0x3c04857c, 0x3ff);
+	reg32_write(0x3c04c17c, 0x3ff);
+	reg32_write(0x3c04c57c, 0x3ff);
+	reg32_write(0x3c000154, 0x3ff);
+	reg32_write(0x3c004154, 0x3ff);
+	reg32_write(0x3c008154, 0x3ff);
+	reg32_write(0x3c00c154, 0x3ff);
+	reg32_write(0x3c010154, 0xff);
+	reg32_write(0x3c014154, 0xff);
+	reg32_write(0x3c018154, 0x3ff);
+	reg32_write(0x3c01c154, 0x3ff);
+	reg32_write(0x3c020154, 0x3ff);
+	reg32_write(0x3c024154, 0x3ff);
+	reg32_write(0x3c080314, 0xb);
+	reg32_write(0x3c0800b8, 0x1);
+	reg32_write(0x3c080090, 0x8);
+	reg32_write(0x3c0800e8, 0x0);
+	reg32_write(0x3c080158, 0xa);
+	reg32_write(0x3c040134, 0x208);
+	reg32_write(0x3c040534, 0x208);
+	reg32_write(0x3c044134, 0x208);
+	reg32_write(0x3c044534, 0x208);
+	reg32_write(0x3c048134, 0x208);
+	reg32_write(0x3c048534, 0x208);
+	reg32_write(0x3c04c134, 0x208);
+	reg32_write(0x3c04c534, 0x208);
+	reg32_write(0x3c040124, 0x618);
+	reg32_write(0x3c040524, 0x618);
+	reg32_write(0x3c044124, 0x618);
+	reg32_write(0x3c044524, 0x618);
+	reg32_write(0x3c048124, 0x618);
+	reg32_write(0x3c048524, 0x618);
+	reg32_write(0x3c04c124, 0x618);
+	reg32_write(0x3c04c524, 0x618);
+	reg32_write(0x3c00010c, 0x21);
+	reg32_write(0x3c00410c, 0x21);
+	reg32_write(0x3c00810c, 0x21);
+	reg32_write(0x3c00c10c, 0x21);
+	reg32_write(0x3c01010c, 0x21);
+	reg32_write(0x3c01410c, 0x21);
+	reg32_write(0x3c01810c, 0x21);
+	reg32_write(0x3c01c10c, 0x21);
+	reg32_write(0x3c02010c, 0x21);
+	reg32_write(0x3c02410c, 0x21);
+	reg32_write(0x3c080060, 0x5);
+	reg32_write(0x3c0801d4, 0x0);
+	reg32_write(0x3c080140, 0x0);
+	reg32_write(0x3c080020, 0x190);
+	reg32_write(0x3c080220, 0x9);
+	reg32_write(0x3c0802c8, 0x0);
+	reg32_write(0x3c04010c, 0x581);
+	reg32_write(0x3c04050c, 0x581);
+	reg32_write(0x3c04410c, 0x581);
+	reg32_write(0x3c04450c, 0x581);
+	reg32_write(0x3c04810c, 0x581);
+	reg32_write(0x3c04850c, 0x581);
+	reg32_write(0x3c04c10c, 0x581);
+	reg32_write(0x3c04c50c, 0x581);
+	reg32_write(0x3c0803e8, 0x1);
+	reg32_write(0x3c080064, 0x5);
+	reg32_write(0x3c0803c0, 0x5555);
+	reg32_write(0x3c0803c4, 0x5555);
+	reg32_write(0x3c0803c8, 0x5555);
+	reg32_write(0x3c0803cc, 0x5555);
+	reg32_write(0x3c0803d0, 0x5555);
+	reg32_write(0x3c0803d4, 0x5555);
+	reg32_write(0x3c0803d8, 0x5555);
+	reg32_write(0x3c0803dc, 0xf000);
+	reg32_write(0x3c080094, 0x0);
+	reg32_write(0x3c0800b4, 0x0);
+	reg32_write(0x3c08031c, 0x21);
+	reg32_write(0x3c080328, 0x24);
+
+	//enable APB bus to access DDRPHY RAM
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
+	//load the 1D training image
+	ddr_load_train_code(FW_1D_IMAGE);
+
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54003, 0x640);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54004, 0x2);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54005, 0x3c3c);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54006, 0x12c);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54007, 0x2000);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54008, 0x101);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5400b, 0x31f);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5400c, 0xc8);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54012, 0x1);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5402f, 0x1c70);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54030, 0x4);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x54031, 0x18);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x5403a, 0x1323);
+
+	//disable APB bus to access DDRPHY RAM
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x1);
+	//Reset MPU and run
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x9);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x1);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x0);
+	wait_ddrphy_training_complete();
+
+	//set the PHY input clock to the desired frequency for pstate 0
+	reg32_write(0x30360054, 0x12c091);
+	reg32_write(0x30360058, 0x0);
+	tmp = reg32_read(0x30360050);
+	tmp |= 0x200;
+	reg32_write(0x30360050, tmp);
+	tmp = reg32_read(0x30360050);
+	tmp &= ~0x10;
+	reg32_write(0x30360050, tmp);
+	do {
+		tmp = reg32_read(0x30360050);
+		if (tmp & 0x80000000)
+			break;
+	} while (1);
+
+	//Halt MPU
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0099, 0x1);
+	//enable APB bus to access DDRPHY RAM
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
+
+	//Load firmware PIE image
+	reg32_write(0x3c240000, 0x10);
+	reg32_write(0x3c240004, 0x400);
+	reg32_write(0x3c240008, 0x10e);
+	reg32_write(0x3c24000c, 0x0);
+	reg32_write(0x3c240010, 0x0);
+	reg32_write(0x3c240014, 0x8);
+	reg32_write(0x3c2400a4, 0xb);
+	reg32_write(0x3c2400a8, 0x480);
+	reg32_write(0x3c2400ac, 0x109);
+	reg32_write(0x3c2400b0, 0x8);
+	reg32_write(0x3c2400b4, 0x448);
+	reg32_write(0x3c2400b8, 0x139);
+	reg32_write(0x3c2400bc, 0x8);
+	reg32_write(0x3c2400c0, 0x478);
+	reg32_write(0x3c2400c4, 0x109);
+	reg32_write(0x3c2400c8, 0x2);
+	reg32_write(0x3c2400cc, 0x10);
+	reg32_write(0x3c2400d0, 0x139);
+	reg32_write(0x3c2400d4, 0xf);
+	reg32_write(0x3c2400d8, 0x7c0);
+	reg32_write(0x3c2400dc, 0x139);
+	reg32_write(0x3c2400e0, 0x44);
+	reg32_write(0x3c2400e4, 0x630);
+	reg32_write(0x3c2400e8, 0x159);
+	reg32_write(0x3c2400ec, 0x14f);
+	reg32_write(0x3c2400f0, 0x630);
+	reg32_write(0x3c2400f4, 0x159);
+	reg32_write(0x3c2400f8, 0x47);
+	reg32_write(0x3c2400fc, 0x630);
+	reg32_write(0x3c240100, 0x149);
+	reg32_write(0x3c240104, 0x4f);
+	reg32_write(0x3c240108, 0x630);
+	reg32_write(0x3c24010c, 0x179);
+	reg32_write(0x3c240110, 0x8);
+	reg32_write(0x3c240114, 0xe0);
+	reg32_write(0x3c240118, 0x109);
+	reg32_write(0x3c24011c, 0x0);
+	reg32_write(0x3c240120, 0x7c8);
+	reg32_write(0x3c240124, 0x109);
+	reg32_write(0x3c240128, 0x0);
+	reg32_write(0x3c24012c, 0x1);
+	reg32_write(0x3c240130, 0x8);
+	reg32_write(0x3c240134, 0x0);
+	reg32_write(0x3c240138, 0x45a);
+	reg32_write(0x3c24013c, 0x9);
+	reg32_write(0x3c240140, 0x0);
+	reg32_write(0x3c240144, 0x448);
+	reg32_write(0x3c240148, 0x109);
+	reg32_write(0x3c24014c, 0x40);
+	reg32_write(0x3c240150, 0x630);
+	reg32_write(0x3c240154, 0x179);
+	reg32_write(0x3c240158, 0x1);
+	reg32_write(0x3c24015c, 0x618);
+	reg32_write(0x3c240160, 0x109);
+	reg32_write(0x3c240164, 0x40c0);
+	reg32_write(0x3c240168, 0x630);
+	reg32_write(0x3c24016c, 0x149);
+	reg32_write(0x3c240170, 0x8);
+	reg32_write(0x3c240174, 0x4);
+	reg32_write(0x3c240178, 0x48);
+	reg32_write(0x3c24017c, 0x4040);
+	reg32_write(0x3c240180, 0x630);
+	reg32_write(0x3c240184, 0x149);
+	reg32_write(0x3c240188, 0x0);
+	reg32_write(0x3c24018c, 0x4);
+	reg32_write(0x3c240190, 0x48);
+	reg32_write(0x3c240194, 0x40);
+	reg32_write(0x3c240198, 0x630);
+	reg32_write(0x3c24019c, 0x149);
+	reg32_write(0x3c2401a0, 0x10);
+	reg32_write(0x3c2401a4, 0x4);
+	reg32_write(0x3c2401a8, 0x18);
+	reg32_write(0x3c2401ac, 0x0);
+	reg32_write(0x3c2401b0, 0x4);
+	reg32_write(0x3c2401b4, 0x78);
+	reg32_write(0x3c2401b8, 0x549);
+	reg32_write(0x3c2401bc, 0x630);
+	reg32_write(0x3c2401c0, 0x159);
+	reg32_write(0x3c2401c4, 0xd49);
+	reg32_write(0x3c2401c8, 0x630);
+	reg32_write(0x3c2401cc, 0x159);
+	reg32_write(0x3c2401d0, 0x94a);
+	reg32_write(0x3c2401d4, 0x630);
+	reg32_write(0x3c2401d8, 0x159);
+	reg32_write(0x3c2401dc, 0x441);
+	reg32_write(0x3c2401e0, 0x630);
+	reg32_write(0x3c2401e4, 0x149);
+	reg32_write(0x3c2401e8, 0x42);
+	reg32_write(0x3c2401ec, 0x630);
+	reg32_write(0x3c2401f0, 0x149);
+	reg32_write(0x3c2401f4, 0x1);
+	reg32_write(0x3c2401f8, 0x630);
+	reg32_write(0x3c2401fc, 0x149);
+	reg32_write(0x3c240200, 0x0);
+	reg32_write(0x3c240204, 0xe0);
+	reg32_write(0x3c240208, 0x109);
+	reg32_write(0x3c24020c, 0xa);
+	reg32_write(0x3c240210, 0x10);
+	reg32_write(0x3c240214, 0x109);
+	reg32_write(0x3c240218, 0x9);
+	reg32_write(0x3c24021c, 0x3c0);
+	reg32_write(0x3c240220, 0x149);
+	reg32_write(0x3c240224, 0x9);
+	reg32_write(0x3c240228, 0x3c0);
+	reg32_write(0x3c24022c, 0x159);
+	reg32_write(0x3c240230, 0x18);
+	reg32_write(0x3c240234, 0x10);
+	reg32_write(0x3c240238, 0x109);
+	reg32_write(0x3c24023c, 0x0);
+	reg32_write(0x3c240240, 0x3c0);
+	reg32_write(0x3c240244, 0x109);
+	reg32_write(0x3c240248, 0x18);
+	reg32_write(0x3c24024c, 0x4);
+	reg32_write(0x3c240250, 0x48);
+	reg32_write(0x3c240254, 0x18);
+	reg32_write(0x3c240258, 0x4);
+	reg32_write(0x3c24025c, 0x58);
+	reg32_write(0x3c240260, 0xa);
+	reg32_write(0x3c240264, 0x10);
+	reg32_write(0x3c240268, 0x109);
+	reg32_write(0x3c24026c, 0x2);
+	reg32_write(0x3c240270, 0x10);
+	reg32_write(0x3c240274, 0x109);
+	reg32_write(0x3c240278, 0x7);
+	reg32_write(0x3c24027c, 0x7c0);
+	reg32_write(0x3c240280, 0x109);
+	reg32_write(0x3c240284, 0x10);
+	reg32_write(0x3c240288, 0x10);
+	reg32_write(0x3c24028c, 0x109);
+	reg32_write(0x3c240290, 0x0);
+	reg32_write(0x3c240294, 0x8140);
+	reg32_write(0x3c240298, 0x10c);
+	reg32_write(0x3c24029c, 0x10);
+	reg32_write(0x3c2402a0, 0x8138);
+	reg32_write(0x3c2402a4, 0x10c);
+	reg32_write(0x3c2402a8, 0x8);
+	reg32_write(0x3c2402ac, 0x7c8);
+	reg32_write(0x3c2402b0, 0x101);
+	reg32_write(0x3c2402b4, 0x8);
+	reg32_write(0x3c2402b8, 0x0);
+	reg32_write(0x3c2402bc, 0x8);
+	reg32_write(0x3c2402c0, 0x8);
+	reg32_write(0x3c2402c4, 0x448);
+	reg32_write(0x3c2402c8, 0x109);
+	reg32_write(0x3c2402cc, 0xf);
+	reg32_write(0x3c2402d0, 0x7c0);
+	reg32_write(0x3c2402d4, 0x109);
+	reg32_write(0x3c2402d8, 0x47);
+	reg32_write(0x3c2402dc, 0x630);
+	reg32_write(0x3c2402e0, 0x109);
+	reg32_write(0x3c2402e4, 0x8);
+	reg32_write(0x3c2402e8, 0x618);
+	reg32_write(0x3c2402ec, 0x109);
+	reg32_write(0x3c2402f0, 0x8);
+	reg32_write(0x3c2402f4, 0xe0);
+	reg32_write(0x3c2402f8, 0x109);
+	reg32_write(0x3c2402fc, 0x0);
+	reg32_write(0x3c240300, 0x7c8);
+	reg32_write(0x3c240304, 0x109);
+	reg32_write(0x3c240308, 0x8);
+	reg32_write(0x3c24030c, 0x8140);
+	reg32_write(0x3c240310, 0x10c);
+	reg32_write(0x3c240314, 0x0);
+	reg32_write(0x3c240318, 0x1);
+	reg32_write(0x3c24031c, 0x8);
+	reg32_write(0x3c240320, 0x8);
+	reg32_write(0x3c240324, 0x4);
+	reg32_write(0x3c240328, 0x8);
+	reg32_write(0x3c24032c, 0x8);
+	reg32_write(0x3c240330, 0x7c8);
+	reg32_write(0x3c240334, 0x101);
+	reg32_write(0x3c240018, 0x0);
+	reg32_write(0x3c24001c, 0x0);
+	reg32_write(0x3c240020, 0x8);
+	reg32_write(0x3c240024, 0x0);
+	reg32_write(0x3c240028, 0x0);
+	reg32_write(0x3c24002c, 0x0);
+	reg32_write(0x3c34039c, 0x400);
+	reg32_write(0x3c24005c, 0x0);
+	reg32_write(0x3c240098, 0x2c);
+	reg32_write(0x3c08002c, 0x32);
+	reg32_write(0x3c080030, 0x64);
+	reg32_write(0x3c080034, 0x3e8);
+	reg32_write(0x3c080038, 0x2c);
+	reg32_write(0x3c240030, 0x0);
+	reg32_write(0x3c240034, 0x173);
+	reg32_write(0x3c240038, 0x60);
+	reg32_write(0x3c24003c, 0x6110);
+	reg32_write(0x3c240040, 0x2152);
+	reg32_write(0x3c240044, 0xdfbd);
+	reg32_write(0x3c240048, 0xffff);
+	reg32_write(0x3c24004c, 0x6152);
+	reg32_write(0x3c300200, 0x00000000);
+	/*
+	 * CalBusy.0 == 1, indicates the calibrator is actively calibrating.
+	 * Wait Calibrating done.
+	 */
+	do {
+		tmp = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x20097);
+		calbusy = tmp & 0x01;
+	} while (calbusy);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x0);
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0x2006e, 0x0);
+	//disable APB bus to access DDRPHY RAM
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0000, 0x1);
+}
diff --git a/board/karo/tx8mm/ddr/helper.c b/board/karo/tx8mm/ddr/helper.c
new file mode 100644
index 0000000000000000000000000000000000000000..a63be80de0950b83e10ee1a8807436eb1033b458
--- /dev/null
+++ b/board/karo/tx8mm/ddr/helper.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spl.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/sections.h>
+
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define IMEM_LEN 32768
+#define DMEM_LEN 16384
+#define IMEM_2D_OFFSET	49152
+
+#define IMEM_OFFSET_ADDR 0x00050000
+#define DMEM_OFFSET_ADDR 0x00054000
+#define DDR_TRAIN_CODE_BASE_ADDR IP2APB_DDRPHY_IPS_BASE_ADDR(0)
+
+/* We need PHY iMEM PHY is 32KB padded */
+void ddr_load_train_code(enum fw_type type)
+{
+	u32 tmp32, i;
+	u32 error = 0;
+	unsigned long pr_to32, pr_from32;
+	unsigned long fw_offset = type ? IMEM_2D_OFFSET : 0;
+	unsigned long imem_start = (unsigned long)&_end + fw_offset;
+	unsigned long dmem_start = imem_start + IMEM_LEN;
+
+	pr_from32 = imem_start;
+	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * IMEM_OFFSET_ADDR;
+	for (i = 0x0; i < IMEM_LEN; ) {
+		tmp32 = readl(pr_from32);
+		writew(tmp32 & 0x0000ffff, pr_to32);
+		pr_to32 += 4;
+		writew((tmp32 >> 16) & 0x0000ffff, pr_to32);
+		pr_to32 += 4;
+		pr_from32 += 4;
+		i += 4;
+	}
+
+	pr_from32 = dmem_start;
+	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * DMEM_OFFSET_ADDR;
+	for (i = 0x0; i < DMEM_LEN;) {
+		tmp32 = readl(pr_from32);
+		writew(tmp32 & 0x0000ffff, pr_to32);
+		pr_to32 += 4;
+		writew((tmp32 >> 16) & 0x0000ffff, pr_to32);
+		pr_to32 += 4;
+		pr_from32 += 4;
+		i += 4;
+	}
+
+	debug("check ddr_train_imem code\n");
+	pr_from32 = imem_start;
+	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * IMEM_OFFSET_ADDR;
+	for (i = 0x0; i < IMEM_LEN;) {
+		tmp32 = (readw(pr_to32) & 0x0000ffff);
+		pr_to32 += 4;
+		tmp32 += ((readw(pr_to32) & 0x0000ffff) << 16);
+
+		if (tmp32 != readl(pr_from32)) {
+			printf("%lx %lx\n", pr_from32, pr_to32);
+			error++;
+		}
+		pr_from32 += 4;
+		pr_to32 += 4;
+		i += 4;
+	}
+	if (error)
+		printf("check ddr_train_imem code fail=%d\n", error);
+	else
+		debug("check ddr_train_imem code pass\n");
+
+	debug("check ddr_train_dmem code\n");
+	pr_from32 = dmem_start;
+	pr_to32 = DDR_TRAIN_CODE_BASE_ADDR + 4 * DMEM_OFFSET_ADDR;
+	for (i = 0x0; i < DMEM_LEN;) {
+		tmp32 = (readw(pr_to32) & 0x0000ffff);
+		pr_to32 += 4;
+		tmp32 += ((readw(pr_to32) & 0x0000ffff) << 16);
+		if (tmp32 != readl(pr_from32)) {
+			printf("%lx %lx\n", pr_from32, pr_to32);
+			error++;
+		}
+		pr_from32 += 4;
+		pr_to32 += 4;
+		i += 4;
+	}
+
+	if (error)
+		printf("check ddr_train_dmem code fail=%d", error);
+	else
+		debug("check ddr_train_dmem code pass\n");
+}
diff --git a/board/karo/tx8mm/ddr/wait_ddrphy_training_complete.c b/board/karo/tx8mm/ddr/wait_ddrphy_training_complete.c
new file mode 100644
index 0000000000000000000000000000000000000000..8b1febe4fc27d7cf502d8a1ce70ddfc2cdce10c5
--- /dev/null
+++ b/board/karo/tx8mm/ddr/wait_ddrphy_training_complete.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/ddr.h>
+#include <asm/arch/clock.h>
+#include "ddr.h"
+
+static inline void poll_pmu_message_ready(void)
+{
+	unsigned int reg;
+
+	do {
+		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0004);
+	} while (reg & 0x1);
+}
+
+static inline void ack_pmu_message_recieve(void)
+{
+	unsigned int reg;
+
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0031, 0x0);
+
+	do {
+		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0004);
+	} while (!(reg & 0x1));
+
+	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0031, 0x1);
+}
+
+static inline unsigned int get_mail(void)
+{
+	unsigned int reg;
+
+	poll_pmu_message_ready();
+
+	reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0032);
+
+	ack_pmu_message_recieve();
+
+	return reg;
+}
+
+static inline unsigned int get_stream_message(void)
+{
+	unsigned int reg, reg2;
+
+	poll_pmu_message_ready();
+
+	reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0032);
+	reg2 = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + 4 * 0xd0034);
+	reg2 = (reg2 << 16) | reg;
+
+	ack_pmu_message_recieve();
+
+	return reg2;
+}
+
+static inline void decode_major_message(unsigned int mail)
+{
+	ddr_dbg("[PMU Major message = 0x%08x]\n", mail);
+}
+
+static inline void decode_streaming_message(void)
+{
+	unsigned int string_index, arg __maybe_unused;
+	int i = 0;
+
+	string_index = get_stream_message();
+	ddr_dbg("	PMU String index = 0x%08x\n", string_index);
+	while (i < (string_index & 0xffff)) {
+		arg = get_stream_message();
+		ddr_dbg("	arg[%d] = 0x%08x\n", i, arg);
+		i++;
+	}
+
+	ddr_dbg("\n");
+}
+
+void wait_ddrphy_training_complete(void)
+{
+	unsigned int mail;
+
+	while (1) {
+		mail = get_mail();
+		decode_major_message(mail);
+		if (mail == 0x08) {
+			decode_streaming_message();
+		} else if (mail == 0x07) {
+			debug("DDR training PASS\n");
+			break;
+		} else if (mail == 0xff) {
+			printf("DDR training FAILED\n");
+			break;
+		}
+	}
+}
diff --git a/board/karo/tx8mm/spl.c b/board/karo/tx8mm/spl.c
new file mode 100644
index 0000000000000000000000000000000000000000..2394d0f1e4629aa40e4cddb8f9ea915ba22c1e05
--- /dev/null
+++ b/board/karo/tx8mm/spl.c
@@ -0,0 +1,306 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <fsl_esdhc.h>
+#include <spl.h>
+#include <mmc.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <power/pmic.h>
+#include <power/bd71837.h>
+#include "ddr/ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void spl_dram_init(void)
+{
+	ddr_init();
+}
+
+#define I2C_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = IMX8MM_PAD_I2C1_SCL_I2C1_SCL | I2C_PAD_CTRL,
+		.gpio_mode = IMX8MM_PAD_I2C1_SCL_GPIO5_IO14 | I2C_PAD_CTRL,
+		.gp = IMX_GPIO_NR(5, 14),
+	},
+	.sda = {
+		.i2c_mode = IMX8MM_PAD_I2C1_SDA_I2C1_SDA | I2C_PAD_CTRL,
+		.gpio_mode = IMX8MM_PAD_I2C1_SDA_GPIO5_IO15 | I2C_PAD_CTRL,
+		.gp = IMX_GPIO_NR(5, 15),
+	},
+};
+
+#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
+	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
+	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
+	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
+	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
+};
+
+static struct tx8m_esdhc_cfg {
+	struct fsl_esdhc_cfg cfg;
+	int clk;
+	const iomux_v3_cfg_t *pads;
+	size_t num_pads;
+	int cd_gpio;
+} tx8mm_sdhc_cfgs[] = {
+	{
+		.cfg = {
+			.esdhc_base = USDHC1_BASE_ADDR,
+			.max_bus_width = 8,
+		},
+		.clk = MXC_ESDHC_CLK,
+		.pads = tx8mm_usdhc1_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
+		.cd_gpio = -EINVAL,
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC2_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC2_CLK,
+		.pads = tx8mm_usdhc2_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
+		.cd_gpio = IMX_GPIO_NR(2, 12),
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC3_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC3_CLK,
+		.pads = tx8mm_usdhc3_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
+		.cd_gpio = IMX_GPIO_NR(3, 8),
+	},
+};
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (eMMC)
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+
+	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		struct mmc *mmc;
+		struct tx8m_esdhc_cfg *cfg;
+
+		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
+			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
+			       CONFIG_SYS_FSL_USDHC_NUM,
+			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
+			return -EINVAL;
+		}
+
+		cfg = &tx8mm_sdhc_cfgs[i];
+		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
+		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
+
+		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
+		if (ret) {
+			printf("Failed to initialize MMC%zu: %d\n", i, ret);
+			continue;
+		}
+
+		mmc = find_mmc_device(i);
+		if (mmc == NULL) {
+			printf("mmc device %zi not found\n", i);
+			continue;
+		}
+		if (board_mmc_getcd(mmc)) {
+			ret = mmc_init(mmc);
+			if (ret) {
+				printf("mmc_init(mmc%zi) failed: %d\n", i, ret);
+			}
+		} else {
+			debug("No Medium found in MMC slot %zi\n", i);
+		}
+	}
+	return 0;
+}
+
+static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
+		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
+
+		if (priv->esdhc_base == cfg->cfg.esdhc_base)
+			return cfg;
+	}
+	return NULL;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
+
+	if (cfg == NULL) {
+		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
+		return 0;
+	}
+	if (cfg->cd_gpio < 0)
+		return 1;
+
+	return !gpio_get_value(cfg->cd_gpio);
+}
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+
+	ret = power_bd71837_init(I2C_PMIC);
+	if (ret)
+		printf("power init failed");
+
+	p = pmic_get("BD71837");
+	pmic_probe(p);
+
+	/* decrease RESET key long push time from the default 10s to 10ms */
+	pmic_reg_write(p, BD71837_PWRONCONFIG1, 0x0);
+
+	/* unlock the PMIC regs */
+	pmic_reg_write(p, BD71837_REGLOCK, 0x1);
+
+	/* increase VDD_DRAM to 0.9v for 3Ghz DDR */
+	pmic_reg_write(p, BD71837_BUCK5_VOLT, 0x2);
+
+	/* increase NVCC_DRAM_1V35 to 1.35v for DDR3L */
+	pmic_reg_write(p, BD71837_BUCK8_VOLT, 0x37);
+
+	/* lock the PMIC regs */
+	pmic_reg_write(p, BD71837_REGLOCK, 0x11);
+
+	return 0;
+}
+#endif
+
+void spl_board_init(void)
+{
+	if (!IS_ENABLED(CONFIG_SPL_DISABLE_BANNER_PRINT))
+		puts("Normal Boot\n");
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	debug("%s: %s\n", __func__, name);
+
+	return 0;
+}
+#endif
+
+#define UART_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL0 |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t uart_pads[] = {
+	IMX8MM_PAD_UART1_RXD_UART1_RX | UART_PAD_CTRL,
+	IMX8MM_PAD_UART1_TXD_UART1_TX | UART_PAD_CTRL,
+};
+
+static int tx8m_spl_iomux_setup(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
+debug("%s@%d:\n", __func__, __LINE__);
+
+	return 0;
+}
+
+void board_init_f(ulong dummy)
+{
+	int ret;
+
+	/* Clear global data */
+	memset((void *)gd, 0, sizeof(gd_t));
+
+	arch_cpu_init();
+
+	tx8m_spl_iomux_setup();
+
+	timer_init();
+
+	preloader_console_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	ret = spl_init();
+	if (ret) {
+		debug("spl_init() failed: %d\n", ret);
+		hang();
+	}
+
+	enable_tzc380();
+
+#if !IS_ENABLED(CONFIG_DM_I2C)
+	/* Adjust pmic voltage to 1.0V for 800M */
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+	power_init_board();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	board_init_r(NULL, 0);
+}
diff --git a/board/karo/tx8mm/tx8mm.c b/board/karo/tx8mm/tx8mm.c
new file mode 100644
index 0000000000000000000000000000000000000000..038cb28389e493e8257206684d1ee3389737435c
--- /dev/null
+++ b/board/karo/tx8mm/tx8mm.c
@@ -0,0 +1,535 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <console.h>
+#include <errno.h>
+#include <fsl_esdhc.h>
+#include <fsl_wdog.h>
+#include <imx_mipi_dsi_bridge.h>
+#include <led.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <mipi_dsi_panel.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <sec_mipi_dsim.h>
+#include <spl.h>
+#include <thermal.h>
+#include <asm-generic/gpio.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/armv8/mmu.h>
+#include <asm/mach-imx/dma.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/video.h>
+#include <dm/uclass.h>
+#include <power/pmic.h>
+#include <power/bd71837.h>
+#include "../common/karo.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if !CONFIG_IS_ENABLED(DM_MMC)
+#define USDHC_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+#define USDHC_GPIO_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_HYS |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_usdhc1_pads[] = {
+	IMX8MM_PAD_SD1_CLK_USDHC1_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_CMD_USDHC1_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA0_USDHC1_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA1_USDHC1_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA2_USDHC1_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA3_USDHC1_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA4_USDHC1_DATA4 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA5_USDHC1_DATA5 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA6_USDHC1_DATA6 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_DATA7_USDHC1_DATA7 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD1_STROBE_USDHC1_STROBE | USDHC_GPIO_PAD_CTRL,
+	IMX8MM_PAD_SD1_RESET_B_USDHC1_RESET_B | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc2_pads[] = {
+	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_SD2_CD_B_GPIO2_IO12 | USDHC_GPIO_PAD_CTRL,
+};
+
+static const iomux_v3_cfg_t tx8mm_usdhc3_pads[] = {
+	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | USDHC_PAD_CTRL,
+	IMX8MM_PAD_NAND_DATA02_GPIO3_IO8 | USDHC_GPIO_PAD_CTRL,
+};
+
+static struct tx8m_esdhc_cfg {
+	struct fsl_esdhc_cfg cfg;
+	int clk;
+	const iomux_v3_cfg_t *pads;
+	size_t num_pads;
+	int cd_gpio;
+} tx8mm_sdhc_cfgs[] = {
+	{
+		.cfg = {
+			.esdhc_base = USDHC1_BASE_ADDR,
+			.max_bus_width = 8,
+		},
+		.clk = MXC_ESDHC_CLK,
+		.pads = tx8mm_usdhc1_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc1_pads),
+		.cd_gpio = -EINVAL,
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC2_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC2_CLK,
+		.pads = tx8mm_usdhc2_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc2_pads),
+		.cd_gpio = IMX_GPIO_NR(2, 12),
+	},
+	{
+		.cfg = {
+			.esdhc_base = USDHC3_BASE_ADDR,
+			.max_bus_width = 4,
+		},
+		.clk = MXC_ESDHC3_CLK,
+		.pads = tx8mm_usdhc3_pads,
+		.num_pads = ARRAY_SIZE(tx8mm_usdhc3_pads),
+		.cd_gpio = IMX_GPIO_NR(3, 8),
+	},
+};
+
+static inline struct tx8m_esdhc_cfg *to_tx8m_esdhc_cfg(struct fsl_esdhc_cfg *priv)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(tx8mm_sdhc_cfgs); i++) {
+		struct tx8m_esdhc_cfg *cfg = &tx8mm_sdhc_cfgs[i];
+
+		if (priv->esdhc_base == cfg->cfg.esdhc_base)
+			return cfg;
+	}
+	return NULL;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct tx8m_esdhc_cfg *cfg = to_tx8m_esdhc_cfg(mmc->priv);
+
+	if (cfg == NULL) {
+		printf("Failed to lookup CD GPIO for MMC dev %p\n", mmc->priv);
+		return 0;
+	}
+	if (cfg->cd_gpio < 0) {
+		debug("%s@%d: 1\n", __func__, __LINE__);
+		return 1;
+	}
+	debug("%s@%d: %d\n", __func__, __LINE__,
+	      !gpio_get_value(cfg->cd_gpio));
+	return !gpio_get_value(cfg->cd_gpio);
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (eMMC)
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+
+	for (size_t i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		struct mmc *mmc;
+		struct tx8m_esdhc_cfg *cfg;
+
+		if (i >= ARRAY_SIZE(tx8mm_sdhc_cfgs)) {
+			printf("Warning: more USDHC controllers configured (%u) than supported by the board: %zu\n",
+			       CONFIG_SYS_FSL_USDHC_NUM,
+			       ARRAY_SIZE(tx8mm_sdhc_cfgs));
+			return -EINVAL;
+		}
+
+		cfg = &tx8mm_sdhc_cfgs[i];
+		if (cfg->cd_gpio >= 0) {
+			gpio_request(cfg->cd_gpio, "MMC CD");
+			gpio_direction_input(cfg->cd_gpio);
+		}
+		cfg->cfg.sdhc_clk = mxc_get_clock(cfg->clk);
+		imx_iomux_v3_setup_multiple_pads(cfg->pads, cfg->num_pads);
+
+		debug("%s@%d: Initialising MMC dev %zu @ %08llx clock=%u\n", __func__, __LINE__,
+		      i, cfg->cfg.esdhc_base, cfg->cfg.sdhc_clk);
+		ret = fsl_esdhc_initialize(bis, &cfg->cfg);
+		if (ret) {
+			printf("Failed to initialize MMC%zu: %d\n", i, ret);
+			continue;
+		}
+
+		mmc = find_mmc_device(i);
+		if (mmc == NULL) {
+			printf("mmc device %zi not found\n", i);
+			continue;
+		}
+		if (board_mmc_getcd(mmc)) {
+			ret = mmc_init(mmc);
+			if (ret)
+				printf("mmc_init(mmc%zi) failed: %d\n", i, ret);
+		} else {
+			debug("No Medium found in MMC slot %zi\n", i);
+		}
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <asm/setup.h>
+#include <asm/bootm.h>
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	struct tag_serialnr serno;
+	char serno_str[64 / 4 + 1];
+
+	get_board_serial(&serno);
+	snprintf(serno_str, sizeof(serno_str), "%08x%08x",
+		 serno.high, serno.low);
+
+	printf("serial-number: %s\n", serno_str);
+
+	fdt_setprop(blob, 0, "serial-number", serno_str, strlen(serno_str));
+	fsl_fdt_fixup_dr_usb(blob, bd);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+#define MDIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_DSE6 |	\
+					     PAD_CTL_PE |	\
+					     PAD_CTL_PUE)
+
+#define FEC_IN_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_FSEL2)
+
+#define FEC_OUT_PAD_CTRL	MUX_PAD_CTRL(PAD_CTL_FSEL2 |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_fec_pads[] = {
+	IMX8MM_PAD_ENET_MDC_ENET1_MDC | MDIO_PAD_CTRL, /* 0x146 */
+	IMX8MM_PAD_ENET_MDIO_ENET1_MDIO | MDIO_PAD_CTRL,
+	IMX8MM_PAD_ENET_TD2_ENET1_TX_CLK | MUX_MODE_SION | FEC_IN_PAD_CTRL, /* 0x40000016 */
+	IMX8MM_PAD_ENET_TD0_ENET1_RGMII_TD0 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MM_PAD_ENET_TD1_ENET1_RGMII_TD1 | FEC_OUT_PAD_CTRL, /* 0x16 */
+	IMX8MM_PAD_ENET_RD0_ENET1_RGMII_RD0 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RD1_ENET1_RGMII_RD1 | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RXC_ENET1_RX_ER | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_RX_CTL_ENET1_RGMII_RX_CTL | FEC_IN_PAD_CTRL, /* 0x90 */
+	IMX8MM_PAD_ENET_TX_CTL_ENET1_RGMII_TX_CTL | FEC_OUT_PAD_CTRL, /* 0x16 */
+};
+
+static int tx8mm_etnphy_init(void)
+{
+	int ret;
+	struct gpio_desc enet0_pwr;
+	struct gpio_desc enet0_rst;
+
+	ret = dm_gpio_lookup_name("gpio1_23", &enet0_pwr);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_lookup_name("gpio1_29", &enet0_rst);
+	if (ret) {
+		printf("Failed to lookup ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_pwr, "ENET0_PWR");
+	if (ret) {
+		printf("Failed to request ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = dm_gpio_request(&enet0_rst, "ENET0_RST");
+	if (ret) {
+		printf("Failed to request ENET0_RST GPIO: %d\n", ret);
+		return ret;
+	}
+
+	dm_gpio_set_dir_flags(&enet0_rst, GPIOD_IS_OUT);
+	dm_gpio_set_dir_flags(&enet0_pwr, GPIOD_IS_OUT);
+	dm_gpio_set_value(&enet0_rst, 0);
+	dm_gpio_set_value(&enet0_pwr, 1);
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_fec_pads,
+					 ARRAY_SIZE(tx8mm_fec_pads));
+
+	mdelay(25);
+	dm_gpio_set_value(&enet0_rst, 1);
+	mdelay(10);
+	return 0;
+}
+
+static int tx8mm_setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *iomuxc_gpr_regs =
+		(void *)IOMUXC_GPR_BASE_ADDR;
+	unsigned char mac[6];
+
+	set_clk_enet(ENET_50MHZ);
+
+	/* Use 50M anatop REF_CLK1 for ENET1, not from external */
+	setbits_le32(&iomuxc_gpr_regs->gpr[1],
+		     IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK);
+
+	imx_get_mac_from_fuse(0, mac);
+	printf("MAC addr: %pM\n", mac);
+
+	return tx8mm_etnphy_init();
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#else
+static inline int tx8mm_setup_fec(void)
+{
+	return 0;
+}
+#endif
+
+int dram_init(void)
+{
+	/* rom_pointer[1] contains the size of RAM occupied by TEE */
+	if (rom_pointer[1])
+		gd->ram_size = PHYS_SDRAM_SIZE - ALIGN(rom_pointer[1], PAGE_SIZE);
+	else
+		gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+int board_fix_fdt(void *blob)
+{
+	return 0;
+}
+
+#define GPIO_PAD_CTRL		MUX_PAD_CTRL(PAD_CTL_PE |	\
+					     PAD_CTL_PUE |	\
+					     PAD_CTL_DSE6)
+
+static const iomux_v3_cfg_t tx8mm_gpio_pads[] = {
+	IMX8MM_PAD_SD2_RESET_B_GPIO2_IO19 | GPIO_PAD_CTRL,
+};
+
+#ifdef CONFIG_SHOW_ACTIVITY
+enum {
+	LED_STATE_INIT = -1,
+	LED_STATE_OFF,
+	LED_STATE_ON,
+	LED_STATE_DISABLED,
+};
+
+static int led_state = LED_STATE_DISABLED;
+static bool tx8m_temp_check_enabled = true;
+static struct udevice *leddev;
+static struct udevice *thermaldev;
+
+#define TEMPERATURE_HOT		80
+#define TEMPERATURE_MIN		-40
+
+static inline int calc_blink_rate(void)
+{
+	int cpu_temp;
+	static int last_temp = INT_MAX;
+	static int avg_count;
+
+	if (!tx8m_temp_check_enabled)
+		return CONFIG_SYS_HZ;
+
+	if (!thermaldev || thermal_get_temp(thermaldev, &cpu_temp))
+		return CONFIG_SYS_HZ / 2;
+
+	if (last_temp == INT_MAX) {
+		last_temp = cpu_temp;
+	} else if (cpu_temp != last_temp) {
+		static int cpu_temps[4];
+
+		if (thermal_get_temp(thermaldev, &cpu_temps[avg_count]))
+			return CONFIG_SYS_HZ / 2;
+		if (++avg_count >= ARRAY_SIZE(cpu_temps)) {
+			int bad = -1;
+			int i;
+
+			for (i = 0; i < avg_count; i++) {
+				if (cpu_temp != cpu_temps[i])
+					bad = i;
+			}
+			if (bad < 0) {
+				debug("CPU temperature changed from %d to %d\n",
+				      last_temp, cpu_temp);
+				last_temp = cpu_temp;
+			} else {
+				debug("Spurious CPU temperature reading %d -> %d -> %d\n",
+				      cpu_temp, cpu_temps[bad], cpu_temps[i - 1]);
+			}
+			avg_count = 0;
+		}
+	} else {
+		avg_count = 0;
+	}
+	return CONFIG_SYS_HZ + CONFIG_SYS_HZ / 10 -
+		(last_temp - TEMPERATURE_MIN) * CONFIG_SYS_HZ /
+		(TEMPERATURE_HOT - TEMPERATURE_MIN);
+}
+
+void show_activity(int arg)
+{
+	static int blink_rate;
+	static ulong last;
+	int ret;
+
+	if (led_state == LED_STATE_INIT) {
+		last = get_timer(0);
+		ret = led_set_state(leddev, LEDST_ON);
+		if (ret == 0)
+			led_state = LED_STATE_ON;
+		else
+			led_state = LED_STATE_DISABLED;
+		blink_rate = calc_blink_rate();
+	} else {
+		if (get_timer(last) > blink_rate) {
+			blink_rate = calc_blink_rate();
+			last = get_timer(0);
+			if (led_state == LED_STATE_ON) {
+				ret = led_set_state(leddev, LEDST_OFF);
+			} else {
+				ret = led_set_state(leddev, LEDST_ON);
+			}
+			if (ret == 0)
+				led_state = 1 - led_state;
+			else
+				led_state = LED_STATE_DISABLED;
+		}
+	}
+
+}
+
+static void tx8m_led_init(void)
+{
+	int ret;
+
+	ret = led_get_by_label("Heartbeat", &leddev);
+	if (ret) {
+		printf("Failed to find LED device: %d\n", ret);
+		return;
+	}
+
+	ret = uclass_get_device_by_name(UCLASS_THERMAL, "cpu-thermal",
+					&thermaldev);
+	if (ret)
+		printf("Failed to find THERMAL device: %d\n", ret);
+
+	led_state = LED_STATE_INIT;
+}
+#else
+static inline void tx8m_led_init(void)
+{
+printf("%s@%d: \n", __func__, __LINE__);
+}
+#endif
+
+int checkboard(void)
+{
+	printf("Board: Ka-Ro TX8M-1610\n");
+	return 0;
+}
+
+int board_init(void)
+{
+	int ret;
+	struct gpio_desc reset_out;
+
+	tx8mm_setup_fec();
+
+	ret = dm_gpio_lookup_name("gpio2_19", &reset_out);
+	if (ret) {
+		printf("Failed to lookup ENET0_PWR GPIO: %d\n", ret);
+		return ret;
+	}
+	ret = dm_gpio_request(&reset_out, "RESET_OUT");
+	if (ret) {
+		printf("Failed to request RESET_OUT GPIO: %d\n", ret);
+		return ret;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(tx8mm_gpio_pads,
+					 ARRAY_SIZE(tx8mm_gpio_pads));
+	tx8m_led_init();
+	return ret;
+}
+
+#ifdef CONFIG_BOARD_EARLY_INIT_R
+int board_early_init_r(void)
+{
+	return 0;
+}
+#endif
+
+int board_late_init(void)
+{
+	int ret;
+	struct src *src_regs = (void *)SRC_BASE_ADDR;
+	struct watchdog_regs *wdog = (void *)WDOG1_BASE_ADDR;
+	u32 srsr = readl(&src_regs->srsr);
+	u16 wrsr = readw(&wdog->wrsr);
+	const char *fdt_file = env_get("fdt_file");
+
+	if (srsr & 0x10 && !(wrsr & WRSR_SFTW))
+		env_set("wdreset", "1");
+	if (had_ctrlc())
+		env_set("safeboot", "1");
+	if (fdt_file) {
+		ret = karo_load_fdt(fdt_file);
+		if (ret)
+			printf("Failed to load FDT from '%s': %d\n",
+			       fdt_file, ret);
+	}
+	return 0;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 1;
+}
+
+void board_quiesce_devices(void)
+{
+}
diff --git a/configs/tx8m-1610_defconfig b/configs/tx8m-1610_defconfig
new file mode 100644
index 0000000000000000000000000000000000000000..24ff902638deef7541cf153536d96fffbc955763
--- /dev/null
+++ b/configs/tx8m-1610_defconfig
@@ -0,0 +1,100 @@
+CONFIG_ARM=y
+CONFIG_ARCH_IMX8M=y
+CONFIG_SYS_TEXT_BASE=0x40200000
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_TX8M=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_DEFAULT_DEVICE_TREE="imx8mm-tx8m-1610"
+CONFIG_FIT=y
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/spl_sd.cfg,SPL_TEXT_BASE=0x7E1000"
+CONFIG_SD_BOOT=y
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTCOMMAND=y
+CONFIG_BOOTCOMMAND="run bootargs_${boot_mode} bootm_cmd"
+CONFIG_PRE_CONSOLE_BUFFER=y
+CONFIG_PRE_CON_BUF_ADDR=0x93F000
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_DEFAULT_FDT_FILE="imx8mm-tx8m-1610.dtb"
+CONFIG_VERSION_VARIABLE=y
+CONFIG_SPL=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_DISABLE_BANNER_PRINT=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x300
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_SPL_USB_HOST_SUPPORT=y
+CONFIG_SPL_USB_GADGET_SUPPORT=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="TX8M U-Boot > "
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_GPT_RENAME=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_READ=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION_ENTRIES_OFF=2048
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_CONTROL=y
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_VARS_UBOOT_CONFIG=y
+CONFIG_BOOTP_DNS=y
+CONFIG_BOOTP_GATEWAY=y
+CONFIG_BOOTP_SUBNETMASK=y
+CONFIG_DM_GPIO=y
+CONFIG_MXC_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MXC=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_MXC_OCOTP=y
+CONFIG_PHY_SMSC=y
+CONFIG_DM_ETH=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX8M=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_THERMAL=y
+CONFIG_NXP_TMU=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_VBUS_DRAW=60
+CONFIG_SDP_LOADADDR=0x40400000
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_FAT_WRITE=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+# CONFIG_EFI_LOADER is not set
diff --git a/include/configs/tx8mm.h b/include/configs/tx8mm.h
new file mode 100644
index 0000000000000000000000000000000000000000..012a3d0223d757d5b49f54306d45b34bf14f58c7
--- /dev/null
+++ b/include/configs/tx8mm.h
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2019 Lothar Waßmann <LW@KARO-electronics.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __IMX8MM_EVK_H
+#define __IMX8MM_EVK_H
+
+#include <linux/sizes.h>
+#include <asm/arch/imx-regs.h>
+
+#ifdef CONFIG_SECURE_BOOT
+#define CONFIG_CSF_SIZE			SZ_8K
+#endif
+
+#define CONFIG_SPL_MAX_SIZE		(148 * 1024)
+#define CONFIG_SYS_MONITOR_LEN		SZ_1M
+#define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION	0x1
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_ENABLE_DDR_TRAINING_DEBUG
+#define CONFIG_USBD_HS
+#define CONFIG_SPL_BSS_START_ADDR	0x00910000
+#define CONFIG_SPL_BSS_MAX_SIZE		SZ_8K
+#define CONFIG_SYS_SPL_MALLOC_START	0x42200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	SZ_512K
+#define CONFIG_SPL_LOAD_FIT_ADDRESS	0
+
+#define CONFIG_MALLOC_F_ADDR		0x00912000 /* malloc f used before GD_FLG_FULL_MALLOC_INIT set */
+
+#define CONFIG_SPL_ABORT_ON_RAW_IMAGE /* For RAW image gives an error info not panic */
+
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_BD71837
+
+#ifndef CONFIG_DM_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC_I2C1
+#endif
+
+#if CONFIG_IS_ENABLED(USB_SUPPORT)
+#define CONFIG_SYS_USB_FAT_BOOT_PARTITION  1
+#define CONFIG_SPL_FS_LOAD_PAYLOAD_NAME "u-boot"
+#endif
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#endif /* CONFIG_SPL_BUILD */
+#define CONFIG_SYS_INIT_SP_ADDR		0x00920000
+
+#define CONFIG_SERIAL_TAG
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_BOARD_EARLY_INIT_R
+#ifdef CONFIG_LED
+#define CONFIG_SHOW_ACTIVITY
+#endif
+
+/* ENET Config */
+#ifdef CONFIG_FEC_MXC
+#define IMX_FEC_BASE			0x30BE0000
+#define CONFIG_FEC_MXC_PHYADDR		0
+#define CONFIG_FEC_XCV_TYPE		RMII
+#endif
+
+#define __pfx(p,v)			(p##v)
+#define _pfx(p,v)			__pfx(p, v)
+
+#define CONFIG_FDTADDR			43000000
+#define FDTADDR_STR			__stringify(CONFIG_FDTADDR)
+
+/* Initial environment variables */
+#ifndef CONFIG_TX8MM_UBOOT_MFG
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"append_bootargs=clk_ignore_unused debug\0"			\
+	"baseboard=mipi-mb\0"						\
+	"board=imx8mm-tx8m-1610\0"					\
+	"boot_mode=mmc\0"						\
+	"bootargs_mmc=run default_bootargs;"				\
+	" setenv bootargs ${bootargs} root=PARTUUID=${uuid_rootfs}"	\
+	" ${append_bootargs}\0"						\
+	"bootargs_nfs=run default_bootargs;"				\
+	" setenv bootargs root=/dev/nfs"				\
+	" nfsroot=${nfs_server}:${nfsroot},nolock ${append_bootargs}\0"	\
+	"bootcmd=run bootcmd_${boot_mode} bootm_cmd\0"			\
+	"bootcmd_mmc=run loadfdt loadkernel bootargs_mmc\0"		\
+	"bootcmd_nfs=run loadfdt loadkernel bootargs_nfs\0"		\
+	"bootm_cmd=booti ${loadaddr} ${initrd_addr} ${fdt_addr}\0"	\
+	"console=ttymxc0,115200 earlycon=ec_imx6q,0x30860000,115200\0"	\
+	"default_bootargs=setenv bootargs init=/linuxrc"		\
+	" console=${console} panic=-1 ro\0"				\
+	"emmc_boot_ack=1\0"						\
+	"emmc_boot_part=1\0"						\
+	"fdt_addr=" FDTADDR_STR "\0"					\
+	"fdt_file=Image-" CONFIG_DEFAULT_FDT_FILE "\0"			\
+	"fdt_high=63000000\0"						\
+	"fdtsave=save mmc ${mmcdev} ${fdt_addr} ${fdt_file}"		\
+	" ${fdt_size}\0"						\
+	"initrd_addr=-\0"						\
+	"initrd_high=63800000\0"					\
+	"linux_image=Image-tx8m-1610.bin\0"					\
+	"loadfdt=if test \"${baseboard}\" != \"\";then"			\
+	" fdtfile=Image-${board}-${baseboard}.dtb;else"		\
+	" fdtfile=Image-${board}.dtb;fi"			\
+	";load mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdtfile}\0"	\
+	"loadkernel=load mmc ${mmcdev}:${mmcpart} ${loadaddr}"		\
+	" ${linux_image}\0"						\
+	"mmcdev=0\0"							\
+	"mmcpart=1\0"							\
+	"uuid_rootfs=0cc66cc0-5458-384d-1610-726f6f746673\0"
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"bootcmd=fastboot 0\0"						\
+	"emmc_boot_ack=1\0"						\
+	"emmc_boot_part=1\0"						\
+	"fastboot_dev=mmc\0"						\
+	"mmcdev=0\0"
+#endif
+
+/* Link Definitions */
+#define CONFIG_LOADADDR			40480000
+
+#define CONFIG_SYS_LOAD_ADDR		_pfx(0x,CONFIG_LOADADDR)
+
+#define CONFIG_ENV_OVERWRITE
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(2048 * 512 - CONFIG_ENV_SIZE)
+#else
+#error "No supported Environment location defined"
+#endif
+#define CONFIG_ENV_SIZE			0x1000
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		((CONFIG_ENV_SIZE + SZ_2K + SZ_16K) * SZ_1K)
+
+#define CONFIG_SYS_SDRAM_BASE		0x40000000
+#define PHYS_SDRAM			0x40000000
+#define PHYS_SDRAM_SIZE			SZ_1G
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + (PHYS_SDRAM_SIZE >> 1))
+
+#define CONFIG_MXC_UART_BASE		UART1_BASE_ADDR
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		2048
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* USDHC */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#define CONFIG_SUPPORT_EMMC_BOOT	/* eMMC specific */
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+#ifndef CONFIG_DM_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		400000
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX7
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+#endif
new file mode 100644
index 0000000000000000000000000000000000000000..001cca700efd7316addf23d545b08d092bc4cd58
GIT binary patch
literal 15414
zcmds73tW^{+JA<3P;LW?NCGN&0U49Pd5f7HEj3BaRTHP87Sa{V#0^W)0>d@KM5WB)
zV|{(OOxUiXm?#y>hLn*=iL@mdvQE?l*=XC_UG3&~ZtpucL|h$zzwdi~KbUi#bI$WW
z&*ePlGIRUP#PLArCk`MMm9p8N3VaBEq5)t^8vXkQaqu6g0KCBqefk2ZRnS)r5X5<b
z%G(P#RPpywfx3?df>E=#Z(kVX=M7;R)ZK3Y_yqVtkfsm#`S*vR8Z`t2X&|aUzzzNS
z!pQz!&_@#v!}|Ncr~%#(6x<)Y`VECK0|7!qf?!OD58QNv7X%L+0NPL=@Cu26Tf)>Z
zFf<%=;odNCP$-1o5C&rrm?6RkhDC(Hq)0F58#V^U4fTh(A)zpNm^Ta_Is}Fc83wmT
z1wzvBzMzh{1@0K(1Chg`V9H2em>B~wHQEoRMF+s0F&gL-H4etaL_%!La2OFY5~5>9
z!zk@2=o>v5M&B3@qvLJ_@7U=uDvk%A(K8`_>`joM8w<Da@u20$!Oe-cK%zkp0sLIJ
z=?|0O)^U3H!+0ZT3=hGr6K?}wV<yDhb}vjxng~f#lHiUh)1lvl<uGIV9WZtJG|(ii
zgrLc*;g7Rsz^vJK!9Au~5Hx)~B;P#;?n${9LS{V=52U8R{b_%Kex^bQF^MpD{ygY+
z-%H?g-wv3+;9*FAXaPL5Xd&E?wi6y+lnIOek^uwe?S;jek3i;<ELif`qY(CB4GdrO
zDlA)(1tA%Au=0s42wZ#^!WX{-E3zMl@sDkXRV!CO&dSx0le-dTKT!sQ9y<oBR{s_5
z%Bg_4xgxB7`Y9N){5T9;-UcC$x5CrU<U!oZcj1}!>tJwB2i&@*0X96l5jGZVhGDBZ
zA?V3(VfMOO2wVLHy!iY^7_$0n2!2X}O)qSQsHeY$(7f+qSl)N=Vo@Q4J@X?BUnjxy
zMWqmte-4U-zrn~2-@(M^K82e$eh-lwe}SlHe}jZg--1|L3}xkJ7+>@ql>dDjtb3^*
zrU*a4KPtAvw36>3+57|SdZiK`c=-&NUj80l-M1U6s`o<Ljvt}=^;hAc${%3ct4H9q
znm3@Pc0W8?^%MNFz7EW_Ct+>Pe;}vkC#Zd^3Eq7BEqJ>2Jgj^3JRELngiVJoK-1B8
z;r(MrV9Vj3L1;P$$Ntp<+nO)H2OoV1mGA!otsj2`uN*%Qr`kV)*H2u4wo~n}zwH+|
z)nS1{r+$MD>!<K`#|5x<eGaxSK7*F7-{AC_FX7`ae}^+)pM`I}w!z7-eul5VmEiMl
zeuZy;_zu25_XAuw_Z|G_$KT+aa~I*<&*$O%&llmsuRp`Z-_OG@zg>i1e*YDIz4$vw
zQkTUl$<!qmqz;R%+p?YAskBQrONUbFvPoTMS<R-%vpIs0-fb!A$qlTZC0`zqpOTs(
zi`s3nm#dP~<-RNAcFC5VkzOj-@>`_mT3MxPGb>mZ&P$O&I!&gTyCo@qtF%*=)t13<
zZJZ=cV57T|JEeqnCLpsp+(L_Oa~VsLPGm|QNpdZtNy=(rm96sJ8kb6S3mLP{Bw0*0
zDJ#Feu9>kE+&2Hlx_V|LYl<XQ%dW_1s%GrAc`}mJk}aK$l55@K*5^x>de*~spn5Y>
zG;3Aq(gkj~G26D?$@ImzGOUy#TT4Q?C)gBvg{%0wJtliI3Wxj}Y4;LWTpODH3})Ld
zleH^c4zi4TIh@*(&!#dvwJxz)Cdv9PIM9{xFIKVJIm=eHlrbA;NUa6PIdhk!%KlL7
zEUj6PktIvol`=Pzm78Nsax7RTrO#vf+OjhjY?XUwrKD%b=Gl$p6S8Kcr!=y%&6Hw7
zaV2$GWfdelu4J{!Dk3Y}%M0pcnNp{f!Ag?NYLyp))aAfGtH`j~K@gxKgH6Q&mvLM_
z8dx;D^1H9sZ0nxy%I#`$<y>98RbD7pC+5mWpLHfj0d>n)5L%w?$UX5G<*vw50><9l
zwPGoyM^4z8sFbye(wYwGZ1e8ybkm(Kl$@TuTaMuZbx1HKKa`>rvW@j4%-~=RCnr6n
zQQD<qjhq~#w2cc02+$zv*WNI>zgiO(Il_g8hH6wnDRg}n3^EuoMf=+YOAGzR5vI{-
z@Jn^z)8dd3w2@c2;PRAzQx+E-kEH6|2+508s}Eo?1tGNE5w}Xs>v=MW*T)CB2FFen
zljx31#{_d)0~_y#tT*aI)i`{+!ENJ4*oPT|Spu=-Q*EWBXd|1Ho4yn`EKbkU9`3MM
zum&e{cU)^iu!D*C8`VjOCTy+dTC+*XXB-piqVHLbO-IJ$^~_o9Lsll9tLY9mQ$wds
zC(H9%6di+otufq;I&Ls3$H`joDmgfbC0_8B8`wy_aWD%&@-dh>k2k1Sb%R^O5hL+>
ztvqkN-srbxGskgt6EqH%(DQzy677`0X$c-0#RlrslOD;$w1iNyT1Q(98nhR?+PR5~
z#lulRal@D&^+v64;{b%au!_@BT_{3qs3U1fciyO_2H|<X7g$8FkDVx7F&V>BZLYYM
zNnu1KWQ-ZiU#O?|BU=$H$5|$Y+KoVDIR2weIyDOq?S0C&z<}q`7GtET%Z}Se>Oi#I
z+dzgJgA;8gIli=N%LIbEutC)WE-|pSpNTrdsBuemO?0$TJG0Y{%Oy=lq>d+o`4L>R
z)UMJ|6z|e)1eW6(XAXAsu%ou59H+VMjosd)i@^^?tqXDSwAW;-f*Y?TMEr*WkE=pM
zR)o?(2w2|0a8FE#?g5wA$Eg!qb~4<4Z@8dJlA7Y`CU(fU@>*lD=$DRt(>jDIujNi8
z6X5(R73+ZK&AX5hwHb!0W>PyFdWB2$SN??t(Idga0OD<<-+fgWH_8$e>EPcuW(4^o
z6a(w|(97eFwaEG^khq{j&Lz~&(KQk0-x!0WuUJC^gJnT&W|z%@I);!1%(K<kgT8T&
zcBaVGuqye0vep|j_;CSCu)_7>kwj=5Ra*O)vja<msSN50L%%xbW>k~oDoOFL>?}Ga
z(x08#I!DovzERyVja#ryjf0BkgBh-T{$=vt2yl!!!$7yVveArS)H=j-G&eFTYNQv<
zM+Ws%Ojd!0c$g1JujkqmM_^ceEXzAu7u*IXT;m{l15?yKpdtn_#-gi_k|+CET3g#Q
zNp45E4tbuCC5Wa!Eq9=%R7D(XP+tOfXDG8X{m{*D%~z9YE;L4_IOHpO-teKZq4$<^
z>sqqQ^9DbY#6@C(#xQOmv-2ZPadmdO!%l)a^4`xWnv%i`#7$VjT(|uEf`*3U2p{=0
zKMETc#d!Y|HU8vzF8@}BJ94%oO%I@K)CG6c>*G}^*>+l$?iWv^#~AFsAGIgYm19(+
zHbT|jxHoSM=3>c|h9;gFO$GD18=Xjo4Wn5JWj$@AorWT7kRH6j2c2CN|FU!4Q#59c
z+90;6Ta(bS1p&wTQA?<*tqhlH<@TRP8!?-ha~qo%O2XCdxYCfJxHodBd}-cF-NIun
zcw=OewMSgupz-%1iOU&OsUgdSquZ3LzS02_wY*-Zmak9YB%Tl`9;@0a^@yvF<Ej&#
z7L<ZW3g{fe;Y)NuhymB_=jXFCN08;uduK2Y*V#8+V^|EjA70YV=l~a|nkzN>2k7Lp
zoPx?2x=@b1dK3&A=Zq^=`S9_WqU9_tnTE<ckB&ph&pKKs*PTA&b+KV;ZXQ|)%}JbU
z(6GqZSgkfrr;FF=;^MU0*y!lUL4Mp=`ed-#pV0uOog__^S?RLEK{Cfb8L_MhO4X$h
z6g7`MMAR=#2uCy^C<u>5{}Bxs5FV9+LW<CddPZyjVzxClQEFxh$JW#+6TaLyRAn~(
zY-*!2>3>^iho!BxrMaoGskx=4wY9CiU5*&XZvUUkosFfX%4@`RQ>=aMooLf8xNdj^
z$W~`!=O5SmqzC6=sa}H5MVM}WVE;ksj0dsoq8n1f`%uvIXVw=L3u3Lk%~K_7%UXPs
z!W4MVtJ{mk5>XI@)1HE3at|z-Mlm_Bsf+T;1hGUY6e<sX<WblYOM@6FH+)f%Su80Q
zMPctrgn7ne4z@JpPhy~f<L}SgQC?Dl4ZQDTk7`<-n#cl)8^0*8sH{XZW7vx0UwRU@
zMmDc+MB1iu6iHZDv83WXPl8I)ZfalOJLcz>G1L-d;bR`v6>Uzb7<bIFq9Uv&(Nz%k
zp7MC6=uAK>_0b(=1QNjtLPhN<&svyBw{o1<;xgn<LMWJyes&#DC8-6eo5w)Kl7Ae#
zE}#emy?hMEuEh&y&r#%7k9(GCHWzI<I7=YMdOC!iOo@Vd7RgR~Je~ZVU>gzc!)4gY
z?>q55UCBbY>x&Vt`2$ZwIm+)!LgBmvFCz1CN4}@aO(-|tU4H#>pF?J*tJnOIWJA}y
z>qIC?4lg3P%6zhZK?eE8;yOUrA$8}_6ls1FncRQvbpS;W_%yW)1r?%~*KsJuyk5E<
zz|9Eu1`1nZekHus=fU+)zI7ddS0UW_B%0AWI{9zuX|x*(hdd74ITPVh?_yj@I=l%P
zz3`BycZN0uJ4fE|G483qj6uQeagBE&+#Kd!qObHJ_c%T@dpLE?LyLElqn#z&?1=4X
zN5r~&kkCbFD&C3+QLIvKG2)07pL-D2hRjU1KnL6t{cgrJ;qPyM>M>-z_2%I%kdT>P
zNs_&Cu;q($raUD7K;>Fb0B^m>n~c~#Siq&>Q?yu;7r{+(|El~N%%K!riN=tvmmmw3
z_?%-)=OV~WMJ#(UZMgcwYk=b{!bZMOn&Y6aut$=%qWy`>CALRO7p?!R>x;XykSnh>
zV*p3@BAtcj{R#6ya=b(gv83!8uc+PO7$M?udLfcMyk!pN-o8<ZwUUx8=6_zfQkNXD
z6U*nO7CXVBAl^Qe8=p%rqHHcD;*)n>v%>&|O;avK3Wiv|0l%a;QF-3YD=(?Q6*c4&
zZP|A3gy8~7+Qj0b`G3BweDrl6`fjGjZdDjI5aoX-$Q~+U*_QvYSXy>wFHBE0O^e}T
z=nqyDkk;ygr3>e!rp`sb`C7ZJrdj?XN9jNcHTWgN_i=gq>j6(`LR;e#BZ-m7zZs6N
z!M4pYbQQ?$ef<3sGUOle*`XV8FE4iSR3u-%kSojOW`A}1l)P<pY*s)610xUx2Kv&D
zNoyJ$%|gEC_j=SNkS`A_7Uzz?{efk9n~I8d6c!ee+=jjmpuZa6BIYd4c`|R~h7B9?
z@^W*Q&7U*g3!x{b+cSI$o(<mWu9%8T%F2rI%0^EE!ck(t1}u#8x;?MlaYdrIDK0DD
z@ZjyfUfd*xjIRgW{44QoH}ew(dWFMx9FDsq*KO(HF~#NEw=BDVJU9DwG{qL|jj8m0
z(2c;}u|#yEAw*K`d^0vccZ9h`8}3*CsY_alV14PMLU%oT#S;bg+LMj7U9_Eoid)dD
zEh4umlo#Lq$9M4(%Dp-(i{?+LwpMJrG@1p3Li4_ZhYlUwUx}cdXD^nNZ%9K?HmCRb
z0t>*8&rU&OmfyB&5bSUgprWu}W=dy1*ekf%UCav%%ypj5Won}N;Cn}&-J-Zq(N>Z+
zBiuY}J7GVw0I~x<@qhjf(%MO`SXPvFB})jsp-IwLtI@;DvKR3RG7FV<h&3E{4}uj7
zkGWkhP9Lvub~Jg)cA8306>$$vOBqNn&KI9Sgu;UkPd=--d*2e!gK_uIB1bFStlblo
zW1Bz@(fI1d`R1TKQ`m>5Vb^VG>K6wEQFtFstvfn>#6@RE(LI$ZEWXNcWAf0QQK)qm
z-_RxP7lj_)<4^Aw(ChgX6FE;?5;-pXr3$nLM3#~r!Cy1?{F-^Z(%H?unS(&StlGsT
z{Y|PA%%WpNDbV|RyuTrroIc_b*_TBYDu^eW(9fm!3+SSD#37;-TzNNC819A7E3atl
z!^x0^(8uNy^Hto$&%9%HUd%nJEWV>m{ZQrMUg)KCcQ1TW(Q9ClTA9c=-JONqrT4%&
zQ;WU>>kSF!tJBbJ4j=T&*5Wn3oS;DY673e3)mVJbZNgX2ID9#kMd9$(qjV$Tlf6BM
zm(X(#>PBL(SjgCi%$M9NMBy^2uU8nC>U661Qt3<BqnsQrHTb{g<2;0n-A#Ono_`{g
zK7OqNo&Frak%{*y$??Bdsuu%4dw;)Jh|ivc3eE3${yR`*Rws|t?%Pwj=e2`JJ?B>i
J?EiG(e*tm14153p

literal 0
HcmV?d00001

-- 
2.7.4

